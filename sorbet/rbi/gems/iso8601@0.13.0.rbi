# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `iso8601` gem.
# Please instead update this file by running `bin/tapioca gem iso8601`.


# source://iso8601//lib/iso8601/version.rb#3
module ISO8601; end

# source://iso8601//lib/iso8601/atomic.rb#4
module ISO8601::Atomic
  include ::Comparable

  # @param other [Atom] The contrast to compare against
  # @return [-1, 0, 1]
  #
  # source://iso8601//lib/iso8601/atomic.rb#46
  def <=>(other); end

  # Returns the value of attribute atom.
  #
  # source://iso8601//lib/iso8601/atomic.rb#7
  def atom; end

  # @param other [#hash] The contrast to compare against
  # @return [Boolean]
  #
  # source://iso8601//lib/iso8601/atomic.rb#56
  def eql?(other); end

  # @return [Fixnum]
  #
  # source://iso8601//lib/iso8601/atomic.rb#62
  def hash; end

  # The float representation
  #
  # @return [Float]
  #
  # source://iso8601//lib/iso8601/atomic.rb#21
  def to_f; end

  # The integer representation
  #
  # @return [Integer]
  #
  # source://iso8601//lib/iso8601/atomic.rb#13
  def to_i; end

  # Returns the ISO 8601 representation for the atom
  #
  # @return [String]
  #
  # source://iso8601//lib/iso8601/atomic.rb#29
  def to_s; end

  # Validates the atom is a Numeric
  #
  # @raise [ISO8601::Errors::TypeError]
  # @return [Boolean]
  #
  # source://iso8601//lib/iso8601/atomic.rb#68
  def valid_atom?(atom); end

  # @raise [ISO8601::Errors::TypeError]
  # @return [Boolean]
  #
  # source://iso8601//lib/iso8601/atomic.rb#73
  def valid_base?(base); end

  # The simplest numeric representation. If modulo equals 0 returns an
  # integer else a float.
  #
  # @return [Numeric]
  #
  # source://iso8601//lib/iso8601/atomic.rb#38
  def value; end
end

# A Date representation.
#
# @example
#   d = ISO8601::Date.new('2014-05-28')
#   d.year  # => 2014
#   d.month # => 5
# @example Week dates
#   d = ISO8601::Date.new('2014-W15-2')
#   d.day   # => 27
#   d.wday  # => 2
#   d.week # => 15
#
# source://iso8601//lib/iso8601/date.rb#17
class ISO8601::Date
  extend ::Forwardable

  # @param input [String] The date pattern
  # @return [Date] a new instance of Date
  #
  # source://iso8601//lib/iso8601/date.rb#36
  def initialize(input); end

  # Forwards the date the given amount of days.
  #
  # @param other [Numeric] The days to add
  # @return [ISO8601::Date] New date resulting of the addition
  #
  # source://iso8601//lib/iso8601/date.rb#56
  def +(other); end

  # Backwards the date the given amount of days.
  #
  # @param other [Numeric] The days to remove
  # @return [ISO8601::Date] New date resulting of the substraction
  #
  # source://iso8601//lib/iso8601/date.rb#67
  def -(other); end

  # @param other [#hash] The contrast to compare against
  # @return [Boolean]
  #
  # source://iso8601//lib/iso8601/date.rb#82
  def ==(other); end

  # The original atoms
  #
  # source://iso8601//lib/iso8601/date.rb#28
  def atoms; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def day(*args, **_arg1, &block); end

  # @param other [#hash] The contrast to compare against
  # @return [Boolean]
  #
  # source://iso8601//lib/iso8601/date.rb#90
  def eql?(other); end

  # @return [Fixnum]
  #
  # source://iso8601//lib/iso8601/date.rb#96
  def hash; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def month(*args, **_arg1, &block); end

  # The separator used in the original ISO 8601 string.
  #
  # source://iso8601//lib/iso8601/date.rb#32
  def separator; end

  # Converts self to an array of atoms.
  #
  # source://iso8601//lib/iso8601/date.rb#74
  def to_a; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_date(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_datetime(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_s(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_time(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def wday(*args, **_arg1, &block); end

  # The calendar week number (1-53)
  #
  # @return [Integer]
  #
  # source://iso8601//lib/iso8601/date.rb#46
  def week; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def year(*args, **_arg1, &block); end

  private

  # Splits the date component into valid atoms.
  #
  # Acceptable patterns:
  #
  # * YYYY
  # * YYYY-MM but not YYYYMM
  # * YYYY-MM-DD, YYYYMMDD
  # * YYYY-Www, YYYYWdd
  # * YYYY-Www-D, YYYYWddD
  # * YYYY-DDD, YYYYDDD
  #
  #
  # @param input [String]
  # @raise [ISO8601::Errors::UnknownPattern]
  # @return [Array<Integer>]
  #
  # source://iso8601//lib/iso8601/date.rb#119
  def atomize(input); end

  # Parses an ordinal date (YYYY-DDD) and returns its atoms.
  #
  # @param year [String] in YYYY form.
  # @param day [String] in DDD form.
  # @param separator [String] the separator found in the input.
  # @param sign [String] the sign found in the input.
  # @return [Array<Integer>] date atoms.
  #
  # source://iso8601//lib/iso8601/date.rb#181
  def atomize_ordinal(year, day, separator, sign); end

  # Parses a week date (YYYY-Www-D, YYYY-Www) and returns its atoms.
  #
  # @param input [String] the date string.
  # @param separator [String] the separator found in the input.
  # @param sign [String] the sign found in the input.
  # @return [Array<Integer>] date atoms.
  #
  # source://iso8601//lib/iso8601/date.rb#164
  def atomize_week_date(input, separator, sign); end

  # Wraps ::Date.new to play nice with ArgumentError.
  #
  # @param atoms [Array<Integer>] The date atoms.
  # @return [::Date]
  #
  # source://iso8601//lib/iso8601/date.rb#207
  def compose(atoms); end

  # Wraps ::Date.parse to play nice with ArgumentError.
  #
  # @param string [String] The formatted date.
  # @return [::Date]
  #
  # source://iso8601//lib/iso8601/date.rb#195
  def parse(string); end

  # source://iso8601//lib/iso8601/date.rb#144
  def parse_date(input); end

  # source://iso8601//lib/iso8601/date.rb#140
  def parse_ordinal(input); end

  # source://iso8601//lib/iso8601/date.rb#136
  def parse_weekdate(input); end
end

# A DateTime representation
#
# @example
#   dt = DateTime.new('2014-05-28T19:53Z')
#   dt.year #=> 2014
#
# source://iso8601//lib/iso8601/date_time.rb#10
class ISO8601::DateTime
  extend ::Forwardable

  # @param date_time [String] The datetime pattern
  # @return [DateTime] a new instance of DateTime
  #
  # source://iso8601//lib/iso8601/date_time.rb#23
  def initialize(date_time); end

  # Addition
  #
  # @param other [Numeric] The seconds to add
  #
  # source://iso8601//lib/iso8601/date_time.rb#33
  def +(other); end

  # Substraction
  #
  # @param other [Numeric] The seconds to substract
  #
  # source://iso8601//lib/iso8601/date_time.rb#43
  def -(other); end

  # @param other [#hash] The contrast to compare against
  # @return [Boolean]
  #
  # source://iso8601//lib/iso8601/date_time.rb#74
  def ==(other); end

  # Converts DateTime to an array of atoms.
  #
  # source://iso8601//lib/iso8601/date_time.rb#59
  def atoms; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def day(*args, **_arg1, &block); end

  # @param other [#hash] The contrast to compare against
  # @return [Boolean]
  #
  # source://iso8601//lib/iso8601/date_time.rb#82
  def eql?(other); end

  # @return [Fixnum]
  #
  # source://iso8601//lib/iso8601/date_time.rb#88
  def hash; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def hour(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def minute(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def month(*args, **_arg1, &block); end

  # Returns the value of attribute second.
  #
  # source://iso8601//lib/iso8601/date_time.rb#19
  def second; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def strftime(*args, **_arg1, &block); end

  # Converts DateTime to an array of atoms.
  #
  # source://iso8601//lib/iso8601/date_time.rb#59
  def to_a; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_date(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_datetime(*args, **_arg1, &block); end

  # Converts DateTime to a floating point number of seconds since the Epoch.
  #
  # source://iso8601//lib/iso8601/date_time.rb#66
  def to_f; end

  # Converts DateTime to a formated string
  #
  # source://iso8601//lib/iso8601/date_time.rb#51
  def to_s; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_time(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def year(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def zone(*args, **_arg1, &block); end

  private

  # Parses an ISO date time, where the date and the time components are
  # optional.
  #
  # It enhances the parsing capabilities of the native DateTime.
  #
  #
  # @param date_time [String] The ISO representation
  # @raise [ISO8601::Errors::UnknownPattern]
  #
  # source://iso8601//lib/iso8601/date_time.rb#103
  def parse(date_time); end

  # Validates the date has the right pattern.
  #
  # Acceptable patterns: YYYY, YYYY-MM-DD, YYYYMMDD or YYYY-MM but not YYYYMM
  #
  # @param input [String] A date component
  # @return [Array<String, nil>]
  #
  # source://iso8601//lib/iso8601/date_time.rb#127
  def parse_date(input); end

  # @return [Array<String, nil>]
  #
  # source://iso8601//lib/iso8601/date_time.rb#138
  def parse_time(input); end

  # If time is provided date must use a complete representation
  #
  # @return [Boolean]
  #
  # source://iso8601//lib/iso8601/date_time.rb#158
  def valid_representation?(date, time); end

  # @return [Boolean]
  #
  # source://iso8601//lib/iso8601/date_time.rb#144
  def valid_separators?(separators); end
end

# The Days atom in a {ISO8601::Duration}
#
# A "calendar day" is the time interval which starts at a certain time of day
# at a certain "calendar day" and ends at the same time of day at the next
# "calendar day".
#
# source://iso8601//lib/iso8601/days.rb#10
class ISO8601::Days
  include ::Comparable
  include ::ISO8601::Atomic

  # @param atom [Numeric] The atom value
  # @return [Days] a new instance of Days
  #
  # source://iso8601//lib/iso8601/days.rb#17
  def initialize(atom); end

  # The Day factor
  #
  # @return [Numeric]
  #
  # source://iso8601//lib/iso8601/days.rb#27
  def factor; end

  # The atom symbol.
  #
  # @return [Symbol]
  #
  # source://iso8601//lib/iso8601/days.rb#43
  def symbol; end

  # The amount of seconds
  #
  # @return [Numeric]
  #
  # source://iso8601//lib/iso8601/days.rb#35
  def to_seconds; end
end

# source://iso8601//lib/iso8601/days.rb#13
ISO8601::Days::AVERAGE_FACTOR = T.let(T.unsafe(nil), Integer)

# A duration representation. When no base is provided, all atoms use an
# average factor to compute the amount of seconds.
#
# @example
#   d = ISO8601::Duration.new('P2Y1MT2H')
#   d.years  # => #<ISO8601::Years:0x000000051adee8 @atom=2.0>
#   d.months # => #<ISO8601::Months:0x00000004f230b0 @atom=1.0>
#   d.days   # => #<ISO8601::Days:0x00000005205468 @atom=0>
#   d.hours  # => #<ISO8601::Hours:0x000000051e02a8 @atom=2.0>
#   d.to_seconds # => 65707200.0
# @example Explicit base date time
#   base = ISO8601::DateTime.new('2014-08017')
#   d.to_seconds(base) # => 65757600.0
# @example Number of seconds versus patterns
#   di = ISO8601::Duration.new(65707200)
#   ds = ISO8601::Duration.new('P65707200S')
#   dp = ISO8601::Duration.new('P2Y1MT2H')
#   di == dp # => true
#   di == ds # => true
#
# source://iso8601//lib/iso8601/duration.rb#26
class ISO8601::Duration
  # @param input [String, Numeric] The duration pattern
  # @return [Duration] a new instance of Duration
  #
  # source://iso8601//lib/iso8601/duration.rb#29
  def initialize(input); end

  # Addition
  #
  # @param other [ISO8601::Duration] The duration to add
  # @return [ISO8601::Duration]
  #
  # source://iso8601//lib/iso8601/duration.rb#106
  def +(other); end

  # Substraction
  #
  # @param other [ISO8601::Duration] The duration to substract
  # @return [ISO8601::Duration]
  #
  # source://iso8601//lib/iso8601/duration.rb#116
  def -(other); end

  # @return [ISO8601::Duration]
  #
  # source://iso8601//lib/iso8601/duration.rb#131
  def -@; end

  # @param other [ISO8601::Duration] The duration to compare
  # @return [Boolean]
  #
  # source://iso8601//lib/iso8601/duration.rb#124
  def ==(other); end

  # @return [ISO8601::Duration] The absolute representation of the duration
  #
  # source://iso8601//lib/iso8601/duration.rb#96
  def abs; end

  # Raw atoms result of parsing the given pattern.
  #
  # @return [Hash<Float>]
  #
  # source://iso8601//lib/iso8601/duration.rb#39
  def atoms; end

  # @return [ISO8601::Days] The days of the duration
  #
  # source://iso8601//lib/iso8601/duration.rb#66
  def days; end

  # @param other [ISO8601::Duration] The duration to compare
  # @return [Boolean]
  #
  # source://iso8601//lib/iso8601/duration.rb#139
  def eql?(other); end

  # @return [Fixnum]
  #
  # source://iso8601//lib/iso8601/duration.rb#145
  def hash; end

  # @return [ISO8601::Hours] The hours of the duration
  #
  # source://iso8601//lib/iso8601/duration.rb#72
  def hours; end

  # @return [ISO8601::Minutes] The minutes of the duration
  #
  # source://iso8601//lib/iso8601/duration.rb#78
  def minutes; end

  # @return [ISO8601::Months] The months of the duration
  #
  # source://iso8601//lib/iso8601/duration.rb#54
  def months; end

  # @return [String] The string representation of the duration
  #
  # source://iso8601//lib/iso8601/duration.rb#43
  def pattern; end

  # @return [ISO8601::Seconds] The seconds of the duration
  #
  # source://iso8601//lib/iso8601/duration.rb#84
  def seconds; end

  # The Integer representation of the duration sign.
  #
  # @return [Integer]
  #
  # source://iso8601//lib/iso8601/duration.rb#92
  def sign; end

  # Converts original input into  a valid ISO 8601 duration pattern.
  #
  # @return [String]
  #
  # source://iso8601//lib/iso8601/duration.rb#153
  def to_pattern(original); end

  # @return [String] The string representation of the duration
  #
  # source://iso8601//lib/iso8601/duration.rb#43
  def to_s; end

  # @param base [ISO8601::DateTime, nil] (nil) The base datetime to
  #   calculate the duration against an specific point in time.
  # @return [Numeric] The duration in seconds
  #
  # source://iso8601//lib/iso8601/duration.rb#166
  def to_seconds(base = T.unsafe(nil)); end

  # @return [ISO8601::Weeks] The weeks of the duration
  #
  # source://iso8601//lib/iso8601/duration.rb#60
  def weeks; end

  # @return [ISO8601::Years] The years of the duration
  #
  # source://iso8601//lib/iso8601/duration.rb#48
  def years; end

  private

  # Splits a duration pattern into valid atoms.
  #
  # Acceptable patterns:
  #
  # * PnYnMnD
  # * PTnHnMnS
  # * PnYnMnDTnHnMnS
  # * PnW
  #
  # Where `n` is any number. If it contains a decimal fraction, a dot (`.`) or
  # comma (`,`) can be used.
  #
  # @param input [String]
  # @return [Hash<Float>]
  #
  # source://iso8601//lib/iso8601/duration.rb#196
  def atomize(input); end

  # @raise [ISO8601::Errors::DurationBaseError]
  #
  # source://iso8601//lib/iso8601/duration.rb#313
  def compare_bases(other, base); end

  # source://iso8601//lib/iso8601/duration.rb#269
  def decompose_atom(value, atom); end

  # Fetch the number of seconds of another element.
  #
  # @param other [ISO8601::Duration, Numeric] Instance of a class to fetch
  #   seconds.
  # @raise [ISO8601::Errors::TypeError] If other param is not an instance of
  #   ISO8601::Duration or Numeric classes
  # @return [Float] Number of seconds of other param Object
  #
  # source://iso8601//lib/iso8601/duration.rb#327
  def fetch_seconds(other, base = T.unsafe(nil)); end

  # Changes the base to compute the months for the right base year
  #
  # source://iso8601//lib/iso8601/duration.rb#175
  def months_to_seconds(base); end

  # source://iso8601//lib/iso8601/duration.rb#224
  def parse(input); end

  # source://iso8601//lib/iso8601/duration.rb#211
  def parse_tokens(tokens); end

  # @param value [Numeric] The seconds to promote
  # @return [ISO8601::Duration]
  #
  # source://iso8601//lib/iso8601/duration.rb#249
  def seconds_to_iso(value); end

  # source://iso8601//lib/iso8601/duration.rb#220
  def sign_to_i(sign); end

  # source://iso8601//lib/iso8601/duration.rb#273
  def to_date_s(sign, *args); end

  # source://iso8601//lib/iso8601/duration.rb#277
  def to_time_s(*args); end

  # @raise [ISO8601::Errors::InvalidFractions]
  # @return [Boolean]
  #
  # source://iso8601//lib/iso8601/duration.rb#305
  def valid_fractions?(values); end

  # @raise [ISO8601::Errors::UnknownPattern]
  # @return [Boolean]
  #
  # source://iso8601//lib/iso8601/duration.rb#288
  def valid_pattern?(components); end

  # @raise [ISO8601::Errors::TypeError]
  #
  # source://iso8601//lib/iso8601/duration.rb#281
  def validate_base(input); end
end

# Contains all ISO8601-specific errors.
#
# source://iso8601//lib/iso8601/errors.rb#6
module ISO8601::Errors; end

# Raise when the base is not suitable.
#
# source://iso8601//lib/iso8601/errors.rb#48
class ISO8601::Errors::DurationBaseError < ::ISO8601::Errors::StandardError
  # @return [DurationBaseError] a new instance of DurationBaseError
  #
  # source://iso8601//lib/iso8601/errors.rb#49
  def initialize(duration); end
end

# Raised when the interval is unexpected
#
# source://iso8601//lib/iso8601/errors.rb#43
class ISO8601::Errors::IntervalError < ::ISO8601::Errors::StandardError; end

# Raised when the given pattern contains an invalid fraction.
#
# source://iso8601//lib/iso8601/errors.rb#22
class ISO8601::Errors::InvalidFractions < ::ISO8601::Errors::StandardError
  # @return [InvalidFractions] a new instance of InvalidFractions
  #
  # source://iso8601//lib/iso8601/errors.rb#23
  def initialize; end
end

# Raised when the given date is valid but out of range.
#
# source://iso8601//lib/iso8601/errors.rb#30
class ISO8601::Errors::RangeError < ::ISO8601::Errors::StandardError
  # @return [RangeError] a new instance of RangeError
  #
  # source://iso8601//lib/iso8601/errors.rb#31
  def initialize(pattern); end
end

# Catch-all exception.
#
# source://iso8601//lib/iso8601/errors.rb#9
class ISO8601::Errors::StandardError < ::StandardError; end

# Raised when the type is unexpected
#
# source://iso8601//lib/iso8601/errors.rb#38
class ISO8601::Errors::TypeError < ::ArgumentError; end

# Raised when the given pattern doesn't fit as ISO 8601 parser.
#
# source://iso8601//lib/iso8601/errors.rb#14
class ISO8601::Errors::UnknownPattern < ::ISO8601::Errors::StandardError
  # @return [UnknownPattern] a new instance of UnknownPattern
  #
  # source://iso8601//lib/iso8601/errors.rb#15
  def initialize(pattern); end
end

# The Hours atom in a {ISO8601::Duration}
#
# source://iso8601//lib/iso8601/hours.rb#6
class ISO8601::Hours
  include ::Comparable
  include ::ISO8601::Atomic

  # @param atom [Numeric] The atom value
  # @return [Hours] a new instance of Hours
  #
  # source://iso8601//lib/iso8601/hours.rb#13
  def initialize(atom); end

  # The Week factor
  #
  # @return [Numeric]
  #
  # source://iso8601//lib/iso8601/hours.rb#23
  def factor; end

  # The atom symbol.
  #
  # @return [Symbol]
  #
  # source://iso8601//lib/iso8601/hours.rb#39
  def symbol; end

  # The amount of seconds
  #
  # @return [Numeric]
  #
  # source://iso8601//lib/iso8601/hours.rb#31
  def to_seconds; end
end

# source://iso8601//lib/iso8601/hours.rb#9
ISO8601::Hours::AVERAGE_FACTOR = T.let(T.unsafe(nil), Integer)

# The Minutes atom in a {ISO8601::Duration}
#
# source://iso8601//lib/iso8601/minutes.rb#6
class ISO8601::Minutes
  include ::Comparable
  include ::ISO8601::Atomic

  # @param atom [Numeric] The atom value
  # @return [Minutes] a new instance of Minutes
  #
  # source://iso8601//lib/iso8601/minutes.rb#13
  def initialize(atom); end

  # The Minute factor
  #
  # @return [Numeric]
  #
  # source://iso8601//lib/iso8601/minutes.rb#23
  def factor; end

  # The atom symbol.
  #
  # @return [Symbol]
  #
  # source://iso8601//lib/iso8601/minutes.rb#39
  def symbol; end

  # The amount of seconds
  #
  # @return [Numeric]
  #
  # source://iso8601//lib/iso8601/minutes.rb#31
  def to_seconds; end
end

# source://iso8601//lib/iso8601/minutes.rb#9
ISO8601::Minutes::AVERAGE_FACTOR = T.let(T.unsafe(nil), Integer)

# A Months atom in a {ISO8601::Duration}
#
# A "calendar month" is the time interval resulting from the division of a
# "calendar year" in 12 time intervals.
#
# A "duration month" is the duration of 28, 29, 30 or 31 "calendar days"
# depending on the start and/or the end of the corresponding time interval
# within the specific "calendar month".
#
# source://iso8601//lib/iso8601/months.rb#13
class ISO8601::Months
  include ::Comparable
  include ::ISO8601::Atomic

  # @param atom [Numeric] The atom value
  # @return [Months] a new instance of Months
  #
  # source://iso8601//lib/iso8601/months.rb#24
  def initialize(atom); end

  # The Month factor
  #
  # @param base [ISO8601::DateTime, nil] (nil) The base datetime to compute
  #   the month length.
  # @return [Numeric]
  #
  # source://iso8601//lib/iso8601/months.rb#37
  def factor(base = T.unsafe(nil)); end

  # The atom symbol.
  #
  # @return [Symbol]
  #
  # source://iso8601//lib/iso8601/months.rb#59
  def symbol; end

  # The amount of seconds
  #
  # @param base [ISO8601::DateTime, nil] (nil) The base datetime to compute
  #   the month length.
  # @return [Numeric]
  #
  # source://iso8601//lib/iso8601/months.rb#51
  def to_seconds(base = T.unsafe(nil)); end

  private

  # source://iso8601//lib/iso8601/months.rb#66
  def calculation(atom, base); end
end

# The "duration month" average is calculated through time intervals of 400
# "duration years". Each cycle of 400 "duration years" has 303 "common
# years" of 365 "calendar days" and 97 "leap years" of 366 "calendar days".
#
# source://iso8601//lib/iso8601/months.rb#20
ISO8601::Months::AVERAGE_FACTOR = T.let(T.unsafe(nil), Integer)

# The Seconds atom in a {ISO8601::Duration}
#
# The second is the base unit of measurement of time in the International
# System of Units (SI) as defined by the International Committee of Weights
# and Measures.
#
# source://iso8601//lib/iso8601/seconds.rb#10
class ISO8601::Seconds
  include ::Comparable
  include ::ISO8601::Atomic

  # @param atom [Numeric] The atom value
  # @return [Seconds] a new instance of Seconds
  #
  # source://iso8601//lib/iso8601/seconds.rb#17
  def initialize(atom); end

  # The Second factor
  #
  # @return [Numeric]
  #
  # source://iso8601//lib/iso8601/seconds.rb#27
  def factor; end

  # The atom symbol.
  #
  # @return [Symbol]
  #
  # source://iso8601//lib/iso8601/seconds.rb#43
  def symbol; end

  # The amount of seconds
  #
  # @return [Numeric]
  #
  # source://iso8601//lib/iso8601/seconds.rb#35
  def to_seconds; end
end

# source://iso8601//lib/iso8601/seconds.rb#13
ISO8601::Seconds::AVERAGE_FACTOR = T.let(T.unsafe(nil), Integer)

# A Time representation
#
# @example
#   t = Time.new('10:11:12')
#   t = Time.new('T10:11:12.5Z')
#   t.hour # => 10
#   t.minute # => 11
#   t.second # => 12.5
#   t.zone # => '+00:00'
#
# source://iso8601//lib/iso8601/time.rb#14
class ISO8601::Time
  extend ::Forwardable

  # @param input [String] The time pattern
  # @param base [Date] The base date to determine the time
  # @return [Time] a new instance of Time
  #
  # source://iso8601//lib/iso8601/time.rb#38
  def initialize(input, base = T.unsafe(nil)); end

  # Forwards the time the given amount of seconds.
  #
  # @param other [Numeric] The seconds to add
  # @return [ISO8601::Time] New time resulting of the addition
  #
  # source://iso8601//lib/iso8601/time.rb#74
  def +(other); end

  # Backwards the date the given amount of seconds.
  #
  # @param other [Numeric] The seconds to remove
  # @return [ISO8601::Time] New time resulting of the substraction
  #
  # source://iso8601//lib/iso8601/time.rb#87
  def -(other); end

  # @param other [#hash] The contrast to compare against
  # @return [Boolean]
  #
  # source://iso8601//lib/iso8601/time.rb#50
  def ==(other); end

  # The original atoms
  #
  # source://iso8601//lib/iso8601/time.rb#33
  def atoms; end

  # @param other [#hash] The contrast to compare against
  # @return [Boolean]
  #
  # source://iso8601//lib/iso8601/time.rb#58
  def eql?(other); end

  # @return [Fixnum]
  #
  # source://iso8601//lib/iso8601/time.rb#64
  def hash; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def hour(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def minute(*args, **_arg1, &block); end

  # The second atom
  #
  # source://iso8601//lib/iso8601/time.rb#29
  def second; end

  # The separator used in the original ISO 8601 string.
  #
  # source://iso8601//lib/iso8601/time.rb#25
  def separator; end

  # Converts self to an array of atoms.
  #
  # source://iso8601//lib/iso8601/time.rb#104
  def to_a; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_date(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_datetime(*args, **_arg1, &block); end

  # Converts self to a time component representation.
  #
  # source://iso8601//lib/iso8601/time.rb#96
  def to_s; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_time(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def zone(*args, **_arg1, &block); end

  private

  # Splits the time component into valid atoms.
  # Acceptable patterns: hh, hh:mm or hhmm and hh:mm:ss or hhmmss. Any form
  # can be prepended by `T`.
  #
  #
  # @param input [String]
  # @raise [ISO8601::Errors::UnknownPattern]
  # @return [Array<Integer, Float>]
  #
  # source://iso8601//lib/iso8601/time.rb#120
  def atomize(input); end

  # Wraps ::DateNew.new to play nice with ArgumentError.
  #
  # @param atoms [Array<Integer>] The time atoms.
  # @param base [::Date] The base date to start computing time.
  # @return [::DateTime]
  #
  # source://iso8601//lib/iso8601/time.rb#183
  def compose(atoms, base); end

  # source://iso8601//lib/iso8601/time.rb#157
  def parse_second(second); end

  # source://iso8601//lib/iso8601/time.rb#149
  def parse_time(time); end

  # source://iso8601//lib/iso8601/time.rb#145
  def parse_timezone(timezone); end

  # source://iso8601//lib/iso8601/time.rb#141
  def require_separator(input); end

  # @param zone [String] The timezone offset as Z or +-hh[:mm].
  # @param require_separator [Boolean] Flag to determine if the separator
  #   consistency check is required as patterns with only hour atom have no
  #   separator but the timezone can.
  # @return [Boolean]
  #
  # source://iso8601//lib/iso8601/time.rb#166
  def valid_zone?(zone, require_separator); end
end

# A Time Interval representation.
# See https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
#
# @example
#   ti = ISO8601::TimeInterval.parse('P1MT2H/2014-05-28T19:53Z')
#   ti.size # => 2635200.0
#   ti2 = ISO8601::TimeInterval.parse('2014-05-28T19:53Z/2014-05-28T20:53Z')
#   ti2.to_f # => 3600.0
# @example
#   start_time = ISO8601::DateTime.new('2014-05-28T19:53Z')
#   end_time = ISO8601::DateTime.new('2014-05-30T19:53Z')
#   ti = ISO8601::TimeInterval.from_datetimes(start_time, end_time)
#   ti.size # => 172800.0 (Seconds)
# @example
#   duration = ISO8601::Duration.new('P1MT2H')
#   end_time = ISO8601::DateTime.new('2014-05-30T19:53Z')
#   ti = ISO8601::TimeInterval.from_duration(duration, end_time)
#   ti.size # => 2635200.0 (Seconds)
# @example
#   start_time = ISO8601::DateTime.new('2014-05-30T19:53Z')
#   duration = ISO8601::Duration.new('P1MT2H', base)
#   ti = ISO8601::TimeInterval.from_duration(start_time, duration)
#   ti.size # => 2635200.0 (Seconds)
#
# source://iso8601//lib/iso8601/time_interval.rb#32
class ISO8601::TimeInterval
  include ::Comparable

  # Dispatches the constructor based on the type of the input.
  #
  # @overload new
  # @overload new
  # @overload new
  # @return [ISO8601::TimeInterval]
  #
  # source://iso8601//lib/iso8601/time_interval.rb#93
  def initialize(input); end

  # @param other [ISO8601::TimeInterval]
  # @return [-1, 0, 1, nil]
  #
  # source://iso8601//lib/iso8601/time_interval.rb#256
  def <=>(other); end

  # Check if two intervarls have no element in common.  This method is the
  # opposite of `#intersect?`.
  #
  # @param other [ISO8601::TimeInterval] Time interval.
  # @raise [ISO8601::Errors::TypeError] if the param is not a TimeInterval.
  # @return [Boolean]
  #
  # source://iso8601//lib/iso8601/time_interval.rb#248
  def disjoint?(other); end

  # Checks if the interval is empty.
  #
  # @return [Boolean]
  #
  # source://iso8601//lib/iso8601/time_interval.rb#149
  def empty?; end

  # The end time (last) of the interval.
  #
  # @return [ISO8601::DateTime] end time
  #
  # source://iso8601//lib/iso8601/time_interval.rb#122
  def end_time; end

  # Equality by hash.
  #
  # @param other [ISO8601::TimeInterval]
  # @return [Boolean]
  #
  # source://iso8601//lib/iso8601/time_interval.rb#268
  def eql?(other); end

  # The start time (first) of the interval.
  #
  # @return [ISO8601::DateTime] start time
  #
  # source://iso8601//lib/iso8601/time_interval.rb#115
  def first; end

  # @return [Fixnum]
  #
  # source://iso8601//lib/iso8601/time_interval.rb#274
  def hash; end

  # Check if a given time is inside the current TimeInterval.
  #
  # @param other [#to_time] DateTime to check if it's
  #   inside the current interval.
  # @raise [ISO8601::Errors::TypeError] if time param is not a compatible
  #   Object.
  # @return [Boolean]
  #
  # source://iso8601//lib/iso8601/time_interval.rb#163
  def include?(other); end

  # Check if two intervarls intersect.
  #
  # @param other [ISO8601::TimeInterval] Another interval to check if they
  #   intersect.
  # @raise [ISO8601::Errors::TypeError] if the param is not a TimeInterval.
  # @return [Boolean]
  #
  # source://iso8601//lib/iso8601/time_interval.rb#213
  def intersect?(other); end

  # Return the intersection between two intervals.
  #
  # @param other [ISO8601::TimeInterval] time interval
  # @raise [ISO8601::Errors::TypeError] if the param is not a TimeInterval.
  # @return [Boolean]
  #
  # source://iso8601//lib/iso8601/time_interval.rb#228
  def intersection(other); end

  # The end time (last) of the interval.
  #
  # @return [ISO8601::DateTime] end time
  #
  # source://iso8601//lib/iso8601/time_interval.rb#122
  def last; end

  # The size of the interval. If any bound is a Duration, the
  # size of the interval is the number of seconds of the interval.
  #
  # @return [Float] Size of the interval in seconds
  #
  # source://iso8601//lib/iso8601/time_interval.rb#141
  def length; end

  # Check if a given time is inside the current TimeInterval.
  #
  # @param other [#to_time] DateTime to check if it's
  #   inside the current interval.
  # @raise [ISO8601::Errors::TypeError] if time param is not a compatible
  #   Object.
  # @return [Boolean]
  #
  # source://iso8601//lib/iso8601/time_interval.rb#163
  def member?(other); end

  # The pattern for the interval.
  #
  # @return [String] The pattern of this interval
  #
  # source://iso8601//lib/iso8601/time_interval.rb#129
  def pattern; end

  # The size of the interval. If any bound is a Duration, the
  # size of the interval is the number of seconds of the interval.
  #
  # @return [Float] Size of the interval in seconds
  #
  # source://iso8601//lib/iso8601/time_interval.rb#141
  def size; end

  # The start time (first) of the interval.
  #
  # @return [ISO8601::DateTime] start time
  #
  # source://iso8601//lib/iso8601/time_interval.rb#115
  def start_time; end

  # Returns true if the interval is a subset of the given interval.
  #
  # @param other [ISO8601::TimeInterval] a time interval.
  # @raise [ISO8601::Errors::TypeError] if time param is not a compatible
  #   Object.
  # @return [Boolean]
  #
  # source://iso8601//lib/iso8601/time_interval.rb#181
  def subset?(other); end

  # Returns true if the interval is a superset of the given interval.
  #
  # @param other [ISO8601::TimeInterval] a time interval.
  # @raise [ISO8601::Errors::TypeError] if time param is not a compatible
  #   Object.
  # @return [Boolean]
  #
  # source://iso8601//lib/iso8601/time_interval.rb#197
  def superset?(other); end

  # The size of the interval. If any bound is a Duration, the
  # size of the interval is the number of seconds of the interval.
  #
  # @return [Float] Size of the interval in seconds
  #
  # source://iso8601//lib/iso8601/time_interval.rb#141
  def to_f; end

  # The pattern for the interval.
  #
  # @return [String] The pattern of this interval
  #
  # source://iso8601//lib/iso8601/time_interval.rb#129
  def to_s; end

  private

  # See the constructor methods.
  #
  # @param atoms [Array]
  #
  # source://iso8601//lib/iso8601/time_interval.rb#348
  def from_atoms(atoms); end

  # Calculates the limits (first, last) and the size of the interval.
  #
  # @param atoms [Array] The atoms result of parsing the pattern.
  # @return [Array<(ISO8601::DateTime, ISO8601::DateTime, ISO8601::Duration)>]
  #
  # source://iso8601//lib/iso8601/time_interval.rb#359
  def limits(atoms); end

  # Initialize a TimeInterval ISO8601 by a pattern. If you initialize it with
  # a duration pattern, the second argument is mandatory because you need to
  # specify an start/end point to calculate the interval.
  #
  # @param pattern [String] This parameter defines a full time interval.
  #   Valid patterns are defined in the ISO8601 as:
  #   * <start_time>/<end_time>
  #   * <start_time>/<duration>
  #   * <duration>/<end_time>
  # @raise [ISO8601::Errors::UnknownPattern] If given pattern is not a valid
  #   ISO8601 pattern.
  #
  # source://iso8601//lib/iso8601/time_interval.rb#308
  def parse(pattern); end

  # source://iso8601//lib/iso8601/time_interval.rb#338
  def parse_start_subpattern(pattern); end

  # Parses a subpattern to a correct type.
  #
  # @param pattern [String]
  # @return [ISO8601::Duration, ISO8601::DateTime]
  #
  # source://iso8601//lib/iso8601/time_interval.rb#332
  def parse_subpattern(pattern); end

  # source://iso8601//lib/iso8601/time_interval.rb#322
  def sort_pair(a, b); end

  # source://iso8601//lib/iso8601/time_interval.rb#368
  def tuple_by_both(atoms); end

  # source://iso8601//lib/iso8601/time_interval.rb#374
  def tuple_by_end(atoms); end

  # source://iso8601//lib/iso8601/time_interval.rb#381
  def tuple_by_start(atoms); end

  # @raise [ISO8601::Errors::UnknownPattern]
  # @return [Boolean]
  #
  # source://iso8601//lib/iso8601/time_interval.rb#388
  def valid_atoms?(atoms); end

  # @return [Boolean]
  #
  # source://iso8601//lib/iso8601/time_interval.rb#393
  def valid_date_time?(time); end

  class << self
    # Initializes a time interval based on two time points.
    #
    # @overload from_datetimes
    # @raise [ISO8601::Errors::TypeError] If both params are not instances of
    #   `ISO8601::DateTime`.
    # @return [ISO8601::TimeInterval]
    #
    # source://iso8601//lib/iso8601/time_interval.rb#47
    def from_datetimes(*atoms); end

    # Initializes a TimeInterval based on a `ISO8601::Duration` and a
    # `ISO8601::DateTime`.  The order of the params define the strategy to
    # compute the interval.
    #
    # @overload from_duration
    # @overload from_duration
    # @raise [ISO8601::Errors::TypeError] If the params aren't a mix of
    #   `ISO8601::DateTime` and `ISO8601::Duration`.
    # @return [ISO8601::TimeInterval]
    #
    # source://iso8601//lib/iso8601/time_interval.rb#72
    def from_duration(*atoms); end

    # source://iso8601//lib/iso8601/time_interval.rb#284
    def guard_from_datetimes(atoms, message); end

    # @raise [ISO8601::Errors::TypeError]
    #
    # source://iso8601//lib/iso8601/time_interval.rb#288
    def guard_from_duration(atoms, message); end

    # Alias of `initialize` to have a closer interface to the core `Time`,
    # `Date` and `DateTime` interfaces.
    #
    # source://iso8601//lib/iso8601/time_interval.rb#107
    def parse(pattern); end

    # @raise [ISO8601::Errors::TypeError]
    # @return [Boolean]
    #
    # source://iso8601//lib/iso8601/time_interval.rb#278
    def valid_date_time?(time, message = T.unsafe(nil)); end
  end
end

# The gem version
#
# source://iso8601//lib/iso8601/version.rb#6
ISO8601::VERSION = T.let(T.unsafe(nil), String)

# A Weeks atom in a {ISO8601::Duration}
#
# source://iso8601//lib/iso8601/weeks.rb#6
class ISO8601::Weeks
  include ::Comparable
  include ::ISO8601::Atomic

  # @param atom [Numeric] The atom value
  # @return [Weeks] a new instance of Weeks
  #
  # source://iso8601//lib/iso8601/weeks.rb#13
  def initialize(atom); end

  # The Week factor
  #
  # @return [Numeric]
  #
  # source://iso8601//lib/iso8601/weeks.rb#23
  def factor; end

  # The atom symbol.
  #
  # @return [Symbol]
  #
  # source://iso8601//lib/iso8601/weeks.rb#39
  def symbol; end

  # The amount of seconds
  #
  # @return [Numeric]
  #
  # source://iso8601//lib/iso8601/weeks.rb#31
  def to_seconds; end
end

# source://iso8601//lib/iso8601/weeks.rb#9
ISO8601::Weeks::AVERAGE_FACTOR = T.let(T.unsafe(nil), Integer)

# A Years atom in a {ISO8601::Duration}
#
# A "calendar year" is the cyclic time interval in a calendar which is
# required for one revolution of the Earth around the Sun and approximated to
# an integral number of "calendar days".
#
# A "duration year" is the duration of 365 or 366 "calendar days" depending
# on the start and/or the end of the corresponding time interval within the
# specific "calendar year".
#
# source://iso8601//lib/iso8601/years.rb#14
class ISO8601::Years
  include ::Comparable
  include ::ISO8601::Atomic

  # @param atom [Numeric] The atom value
  # @return [Years] a new instance of Years
  #
  # source://iso8601//lib/iso8601/years.rb#25
  def initialize(atom); end

  # The Year factor
  #
  # @param base [ISO8601::DateTime, nil] (nil) The base datetime to compute
  #   the year length.
  # @return [Integer]
  #
  # source://iso8601//lib/iso8601/years.rb#38
  def factor(base = T.unsafe(nil)); end

  # The atom symbol.
  #
  # @return [Symbol]
  #
  # source://iso8601//lib/iso8601/years.rb#72
  def symbol; end

  # The amount of seconds
  #
  # TODO: Fractions of year will fail
  #
  #
  # @param base [ISO8601::DateTime, nil] (nil) The base datetime to compute
  #   the year length.
  # @return [Numeric]
  #
  # source://iso8601//lib/iso8601/years.rb#58
  def to_seconds(base = T.unsafe(nil)); end

  private

  # source://iso8601//lib/iso8601/years.rb#78
  def adjusted_factor(atom, base); end

  # source://iso8601//lib/iso8601/years.rb#82
  def year(atom, base); end
end

# The "duration year" average is calculated through time intervals of 400
# "duration years". Each cycle of 400 "duration years" has 303 "common
# years" of 365 "calendar days" and 97 "leap years" of 366 "calendar days".
#
# source://iso8601//lib/iso8601/years.rb#21
ISO8601::Years::AVERAGE_FACTOR = T.let(T.unsafe(nil), Integer)
