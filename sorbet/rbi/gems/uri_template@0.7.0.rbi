# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `uri_template` gem.
# Please instead update this file by running `bin/tapioca gem uri_template`.


# A base module for all implementations of a uri template.
#
# source://uri_template//lib/uri_template.rb#25
module URITemplate
  extend ::URITemplate::ClassMethods

  mixes_in_class_methods ::URITemplate::ClassMethods

  # Concatenate two template with conversion.
  #
  # @example
  #   tpl = URITemplate::RFC6570.new('foo')
  #   (tpl + '{bar}' ).pattern #=> 'foo{bar}'
  # @param other [URITemplate, String, ...]
  # @return URITemplate
  def +(other, *args, &block); end

  # Tries to concatenate two templates, as if they were path segments.
  # Removes double slashes or insert one if they are missing.
  #
  # @example
  #   tpl = URITemplate::RFC6570.new('/xy/')
  #   (tpl / '/z/' ).pattern #=> '/xy/z/'
  #   (tpl / 'z/' ).pattern #=> '/xy/z/'
  #   (tpl / '{/z}' ).pattern #=> '/xy{/z}'
  #   (tpl / 'a' / 'b' ).pattern #=> '/xy/a/b'
  # @param other [URITemplate, String, ...]
  # @return URITemplate
  def /(other, *args, &block); end

  # Compares two template patterns.
  def ==(other, *args, &block); end

  # Concatenate two template with conversion.
  #
  # @example
  #   tpl = URITemplate::RFC6570.new('foo')
  #   (tpl + '{bar}' ).pattern #=> 'foo{bar}'
  # @param other [URITemplate, String, ...]
  # @return URITemplate
  def >>(other, *args, &block); end

  # Returns whether this uri-template includes a host name
  #
  # This method is usefull to check wheter this template will generate
  # or match a uri with a host.
  #
  # @example
  #   URITemplate.new('/foo').host? #=> false
  #   URITemplate.new('//example.com/foo').host? #=> true
  #   URITemplate.new('//{host}/foo').host? #=> true
  #   URITemplate.new('http://example.com/foo').host? #=> true
  #   URITemplate.new('{scheme}://example.com/foo').host? #=> true
  # @return [Boolean]
  # @see #scheme?
  #
  # source://uri_template//lib/uri_template.rb#300
  def absolute?; end

  # Concatenate two template with conversion.
  #
  # @example
  #   tpl = URITemplate::RFC6570.new('foo')
  #   (tpl + '{bar}' ).pattern #=> 'foo{bar}'
  # @param other [URITemplate, String, ...]
  # @return URITemplate
  def concat(other, *args, &block); end

  # source://uri_template//lib/uri_template.rb#384
  def concat_without_coercion(other); end

  # Compares two template patterns.
  def eq(other, *args, &block); end

  # source://uri_template//lib/uri_template.rb#331
  def eq_without_coercion(other); end

  # Expands this uri template with the given variables.
  # The variables should be converted to strings using {Utils#object_to_param}.
  #
  # The keys in the variables hash are converted to
  # strings in order to support the Ruby 1.9 hash syntax.
  #
  # If the variables are given as an array, they will be matched against the variables in the template based on their order.
  #
  # @param variables [#map, Array]
  # @raise [Unconvertable] if a variable could not be converted to a string.
  # @raise [InvalidValue] if a value is not suiteable for a certain variable ( e.g. a string when a list is expected ).
  # @return String
  #
  # source://uri_template//lib/uri_template.rb#208
  def expand(variables = T.unsafe(nil)); end

  # Works like #expand with two differences:
  #
  #  - the result is a uri template instead of string
  #  - undefined variables are left in the template
  #
  # @param variables [#map, Array]
  # @return [URITemplate]
  # @see {#expand}
  #
  # source://uri_template//lib/uri_template.rb#223
  def expand_partial(variables = T.unsafe(nil)); end

  # Returns whether this uri-template includes a host name
  #
  # This method is usefull to check wheter this template will generate
  # or match a uri with a host.
  #
  # @example
  #   URITemplate.new('/foo').host? #=> false
  #   URITemplate.new('//example.com/foo').host? #=> true
  #   URITemplate.new('//{host}/foo').host? #=> true
  #   URITemplate.new('http://example.com/foo').host? #=> true
  #   URITemplate.new('{scheme}://example.com/foo').host? #=> true
  # @return [Boolean]
  # @see #scheme?
  #
  # source://uri_template//lib/uri_template.rb#300
  def host?; end

  # Tries to concatenate two templates, as if they were path segments.
  # Removes double slashes or insert one if they are missing.
  #
  # @example
  #   tpl = URITemplate::RFC6570.new('/xy/')
  #   (tpl / '/z/' ).pattern #=> '/xy/z/'
  #   (tpl / 'z/' ).pattern #=> '/xy/z/'
  #   (tpl / '{/z}' ).pattern #=> '/xy{/z}'
  #   (tpl / 'a' / 'b' ).pattern #=> '/xy/a/b'
  # @param other [URITemplate, String, ...]
  # @return URITemplate
  def path_concat(other, *args, &block); end

  # source://uri_template//lib/uri_template.rb#351
  def path_concat_without_coercion(other); end

  # Returns the pattern for this template.
  #
  # @return String
  #
  # source://uri_template//lib/uri_template.rb#324
  def pattern; end

  # Opposite of {#absolute?}
  #
  # @return [Boolean]
  #
  # source://uri_template//lib/uri_template.rb#448
  def relative?; end

  # Returns whether this uri-template includes a scheme
  #
  # This method is usefull to check wheter this template will generate
  # or match a uri with a scheme.
  #
  # @example
  #   URITemplate.new('/foo').scheme? #=> false
  #   URITemplate.new('//example.com/foo').scheme? #=> false
  #   URITemplate.new('http://example.com/foo').scheme? #=> true
  #   URITemplate.new('{scheme}://example.com/foo').scheme? #=> true
  # @return [Boolean]
  # @see #host?
  #
  # source://uri_template//lib/uri_template.rb#317
  def scheme?; end

  # Returns the number of static characters in this template.
  # This method is useful for routing, since it's often pointful to use the url with fewer variable characters.
  # For example 'static' and 'sta\\{var\\}' both match 'static', but in most cases 'static' should be prefered over 'sta\\{var\\}' since it's more specific.
  #
  # @example
  #   URITemplate.new('/xy/').static_characters #=> 4
  #   URITemplate.new('{foo}').static_characters #=> 0
  #   URITemplate.new('a{foo}b').static_characters #=> 2
  # @return Numeric
  #
  # source://uri_template//lib/uri_template.rb#282
  def static_characters; end

  # Returns the pattern for this template.
  #
  # @return String
  #
  # source://uri_template//lib/uri_template.rb#324
  def to_s; end

  # Returns the tokens of this templates. Tokens should include either {Literal} or {Expression}.
  #
  # @abstract
  # @return [Array<URITemplate::Token>]
  #
  # source://uri_template//lib/uri_template.rb#258
  def tokens; end

  # Returns the type of this template. The type is a symbol which can be used in {.resolve_class} to resolve the type of this template.
  #
  # @abstract
  # @return [Symbol]
  #
  # source://uri_template//lib/uri_template.rb#250
  def type; end

  # Returns an array containing all variables. Repeated variables are ignored. The concrete order of the variables may change.
  #
  # @example
  #   URITemplate.new('{foo}{bar}{baz}').variables #=> ['foo','bar','baz']
  #   URITemplate.new('{a}{c}{a}{b}').variables #=> ['a','c','b']
  # @return [Array<String>]
  #
  # source://uri_template//lib/uri_template.rb#268
  def variables; end

  private

  # @raise [ArgumentError]
  #
  # source://uri_template//lib/uri_template.rb#230
  def normalize_variables(variables); end

  # @api private
  #
  # source://uri_template//lib/uri_template.rb#400
  def remove_double_slash(first_tokens, second_tokens); end

  # @api private
  #
  # source://uri_template//lib/uri_template.rb#413
  def scheme_and_host; end

  class << self
    # Applies a method to a URITemplate with another URITemplate as argument.
    # This is a useful shorthand since both URITemplates are automatically coerced.
    #
    # @example
    #   tpl = URITemplate.new('foo')
    #   URITemplate.apply( tpl, :/, 'bar' ).pattern #=> 'foo/bar'
    #   URITemplate.apply( 'baz', :/, tpl ).pattern #=> 'baz/foo'
    #   URITemplate.apply( 'bla', :/, 'blub' ).pattern #=> 'bla/blub'
    #
    # source://uri_template//lib/uri_template.rb#167
    def apply(a, method, b, *args); end

    # Tries to coerce two URITemplates into a common representation.
    # Returns an array with two {URITemplate}s and two booleans indicating which of the two were converted or raises an ArgumentError.
    #
    # @example
    #   URITemplate.coerce( URITemplate.new(:rfc6570,'{x}'), '{y}' ) #=> [URITemplate.new(:rfc6570,'{x}'), URITemplate.new(:rfc6570,'{y}'), false, true]
    #   URITemplate.coerce( '{y}', URITemplate.new(:rfc6570,'{x}') ) #=> [URITemplate.new(:rfc6570,'{y}'), URITemplate.new(:rfc6570,'{x}'), true, false]
    # @raise [ArgumentError]
    # @return [Tuple<URITemplate,URITemplate,Bool,Bool>]
    #
    # source://uri_template//lib/uri_template.rb#131
    def coerce(a, b); end

    # @api private
    #
    # source://uri_template//lib/uri_template.rb#173
    def coerce_first_arg(meth); end

    # Creates an uri template using an implementation.
    # The args should at least contain a pattern string.
    # Symbols in the args are used to determine the actual implementation.
    #
    # @example
    #   tpl = URITemplate.new('{x}') # a new template using the default implementation
    #   tpl.expand('x'=>'y') #=> 'y'
    # @example
    #   tpl = URITemplate.new(:colon,'/:x') # a new template using the colon implementation
    #
    # source://uri_template//lib/uri_template.rb#118
    def new(*args); end

    # Looks up which implementation to use.
    # Extracts all symbols from args and looks up the first in {VERSIONS}.
    #
    # @example
    #   URITemplate.resolve_class() #=> [ URITemplate::RFC6570, [] ]
    #   URITemplate.resolve_class(:colon) #=> [ URITemplate::Colon, [] ]
    #   URITemplate.resolve_class("template",:rfc6570) #=> [ URITemplate::RFC6570, ["template"] ]
    # @raise ArgumentError when no class was found.
    # @return Array an array of the class to use and the unused parameters.
    #
    # source://uri_template//lib/uri_template.rb#100
    def resolve_class(*args); end
  end
end

# Helper module which defines class methods for all uri template
# classes.
#
# source://uri_template//lib/uri_template.rb#29
module URITemplate::ClassMethods
  # Same as {.try_convert} but raises an ArgumentError when the given argument could not be converted.
  #
  # @raise ArgumentError if the argument is unconvertable
  # @return [URITemplate]
  #
  # source://uri_template//lib/uri_template.rb#48
  def convert(x); end

  # source://uri_template//lib/uri_template.rb#56
  def included(base); end

  # Tries to convert the given argument into an {URITemplate}.
  # Returns nil if this fails.
  #
  # @return [nil|{URITemplate}]
  #
  # source://uri_template//lib/uri_template.rb#34
  def try_convert(x); end
end

# A colon based template denotes variables with a colon.
#
# This template type is somewhat compatible with sinatra.
#
# @example
#   tpl = URITemplate::Colon.new('/foo/:bar')
#   tpl.extract('/foo/baz') #=> {'bar'=>'baz'}
#   tpl.expand('bar'=>'boom') #=> '/foo/boom'
#
# source://uri_template//lib/uri_template/colon.rb#40
class URITemplate::Colon
  include ::URITemplate
  extend ::URITemplate::ClassMethods

  # @raise [ArgumentError]
  # @return [Colon] a new instance of Colon
  #
  # source://uri_template//lib/uri_template/colon.rb#160
  def initialize(pattern); end

  # Extracts variables from an uri.
  #
  # @param uri [String]
  # @return nil,Hash
  #
  # source://uri_template//lib/uri_template/colon.rb#169
  def extract(uri); end

  # Returns the value of attribute pattern.
  #
  # source://uri_template//lib/uri_template/colon.rb#142
  def pattern; end

  # source://uri_template//lib/uri_template/colon.rb#192
  def to_r; end

  # source://uri_template//lib/uri_template/colon.rb#196
  def tokens; end

  # source://uri_template//lib/uri_template/colon.rb#188
  def type; end

  protected

  # source://uri_template//lib/uri_template/colon.rb#202
  def tokenize!; end

  class << self
    # Tries to convert the value into a colon-template.
    #
    # @example
    #   URITemplate::Colon.try_convert('/foo/:bar/').pattern #=> '/foo/:bar/'
    #   URITemplate::Colon.try_convert(URITemplate.new(:rfc6570, '/foo/{bar}/')).pattern #=> '/foo/{:bar}/'
    #
    # source://uri_template//lib/uri_template/colon.rb#148
    def try_convert(x); end
  end
end

# source://uri_template//lib/uri_template/colon.rb#46
class URITemplate::Colon::InvalidValue < ::StandardError
  include ::URITemplate::InvalidValue

  # @return [InvalidValue] a new instance of InvalidValue
  #
  # source://uri_template//lib/uri_template/colon.rb#52
  def initialize(variable, value); end

  # Returns the value of attribute value.
  #
  # source://uri_template//lib/uri_template/colon.rb#50
  def value; end

  # Returns the value of attribute variable.
  #
  # source://uri_template//lib/uri_template/colon.rb#50
  def variable; end

  protected

  # source://uri_template//lib/uri_template/colon.rb#63
  def generate_message; end
end

# source://uri_template//lib/uri_template/colon.rb#58
class URITemplate::Colon::InvalidValue::SplatIsNotAnArray < ::URITemplate::Colon::InvalidValue; end

# source://uri_template//lib/uri_template/colon.rb#69
class URITemplate::Colon::Token; end

# source://uri_template//lib/uri_template/colon.rb#96
class URITemplate::Colon::Token::Splat < ::URITemplate::Colon::Token::Variable
  # @return [Splat] a new instance of Splat
  #
  # source://uri_template//lib/uri_template/colon.rb#102
  def initialize(index); end

  # source://uri_template//lib/uri_template/colon.rb#107
  def expand(vars); end

  # Returns the value of attribute index.
  #
  # source://uri_template//lib/uri_template/colon.rb#100
  def index; end

  # source://uri_template//lib/uri_template/colon.rb#116
  def to_r; end
end

# source://uri_template//lib/uri_template/colon.rb#98
URITemplate::Colon::Token::Splat::SPLAT = T.let(T.unsafe(nil), String)

# source://uri_template//lib/uri_template/colon.rb#122
class URITemplate::Colon::Token::Static < ::URITemplate::Colon::Token
  include ::URITemplate::Token
  include ::URITemplate::Literal

  # @return [Static] a new instance of Static
  #
  # source://uri_template//lib/uri_template/colon.rb#126
  def initialize(str); end

  # source://uri_template//lib/uri_template/colon.rb#130
  def expand(_); end

  # source://uri_template//lib/uri_template/colon.rb#134
  def to_r; end
end

# source://uri_template//lib/uri_template/colon.rb#71
class URITemplate::Colon::Token::Variable < ::URITemplate::Colon::Token
  include ::URITemplate::Token
  include ::URITemplate::Expression

  # @return [Variable] a new instance of Variable
  #
  # source://uri_template//lib/uri_template/colon.rb#77
  def initialize(name); end

  # source://uri_template//lib/uri_template/colon.rb#82
  def expand(vars); end

  # Returns the value of attribute name.
  #
  # source://uri_template//lib/uri_template/colon.rb#75
  def name; end

  # source://uri_template//lib/uri_template/colon.rb#86
  def to_r; end

  # source://uri_template//lib/uri_template/colon.rb#90
  def to_s; end
end

# source://uri_template//lib/uri_template/colon.rb#44
URITemplate::Colon::VAR = T.let(T.unsafe(nil), Regexp)

# A module which all non-literal tokens should include.
#
# source://uri_template//lib/uri_template/expression.rb#25
module URITemplate::Expression
  include ::URITemplate::Token

  # @return [Boolean]
  #
  # source://uri_template//lib/uri_template/expression.rb#35
  def expression?; end

  # @return [Boolean]
  #
  # source://uri_template//lib/uri_template/expression.rb#31
  def literal?; end

  # Returns the value of attribute variables.
  #
  # source://uri_template//lib/uri_template/expression.rb#29
  def variables; end
end

# @api private
#
# source://uri_template//lib/uri_template.rb#67
URITemplate::HOST_REGEX = T.let(T.unsafe(nil), Regexp)

# A base class for all errors which will be raised upon invalid syntax.
#
# source://uri_template//lib/uri_template.rb#187
module URITemplate::Invalid; end

# A base class for all errors which will be raised when a variable value
# is not allowed for a certain expansion.
#
# source://uri_template//lib/uri_template.rb#192
module URITemplate::InvalidValue; end

# A module which all literal tokens should include.
#
# source://uri_template//lib/uri_template/literal.rb#25
module URITemplate::Literal
  include ::URITemplate::Token

  # @return [Boolean]
  #
  # source://uri_template//lib/uri_template/literal.rb#57
  def ends_with_slash?; end

  # source://uri_template//lib/uri_template/literal.rb#45
  def expand(_); end

  # source://uri_template//lib/uri_template/literal.rb#49
  def expand_partial(_); end

  # @return [Boolean]
  #
  # source://uri_template//lib/uri_template/literal.rb#37
  def expression?; end

  # @return [Boolean]
  #
  # source://uri_template//lib/uri_template/literal.rb#33
  def literal?; end

  # source://uri_template//lib/uri_template/literal.rb#41
  def size; end

  # @return [Boolean]
  #
  # source://uri_template//lib/uri_template/literal.rb#53
  def starts_with_slash?; end

  # Returns the value of attribute string.
  #
  # source://uri_template//lib/uri_template/literal.rb#31
  def string; end

  # Returns the value of attribute string.
  def to_s; end
end

# source://uri_template//lib/uri_template/literal.rb#29
URITemplate::Literal::SLASH = T.let(T.unsafe(nil), String)

# A uri template which should comply with the rfc 6570 ( http://tools.ietf.org/html/rfc6570 ).
#
# @note Most specs and examples refer to this class directly, because they are acutally refering to this specific implementation. If you just want uri templates, you should rather use the methods on {URITemplate} to create templates since they will select an implementation.
#
# source://uri_template//lib/uri_template/rfc6570.rb#34
class URITemplate::RFC6570
  include ::URITemplate
  extend ::URITemplate::ClassMethods
  extend ::Forwardable
  extend ::URITemplate::RFC6570::ClassMethods

  # @option :lazy
  # @param pattern_or_tokens [String, Array] either a pattern as String or an Array of tokens
  # @param options [Hash] some options
  # @param :lazy [Hash] a customizable set of options
  # @return [RFC6570] a new instance of RFC6570
  #
  # source://uri_template//lib/uri_template/rfc6570.rb#294
  def initialize(pattern_or_tokens, options = T.unsafe(nil)); end

  # Alias for to_r.=== . Tests whether this template matches a given uri.
  #
  # @return TrueClass, FalseClass
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def ===(*args, **_arg1, &block); end

  # Extracts variables from a uri ( given as string ) or an instance of MatchData ( which was matched by the regexp of this template.
  # The actual result depends on the value of post_processing.
  # This argument specifies whether pair arrays should be converted to hashes.
  #
  # @example Default Processing
  #   URITemplate::RFC6570.new('{var}').extract('value') #=> {'var'=>'value'}
  #   URITemplate::RFC6570.new('{&args*}').extract('&a=1&b=2') #=> {'args'=>{'a'=>'1','b'=>'2'}}
  #   URITemplate::RFC6570.new('{&arg,arg}').extract('&arg=1&arg=2') #=> {'arg'=>'2'}
  # @example No Processing
  #   URITemplate::RFC6570.new('{var}').extract('value', URITemplate::RFC6570::NO_PROCESSING) #=> [['var','value']]
  #   URITemplate::RFC6570.new('{&args*}').extract('&a=1&b=2', URITemplate::RFC6570::NO_PROCESSING) #=> [['args',[['a','1'],['b','2']]]]
  #   URITemplate::RFC6570.new('{&arg,arg}').extract('&arg=1&arg=2', URITemplate::RFC6570::NO_PROCESSING) #=> [['arg','1'],['arg','2']]
  # @example Extraction cruces
  #   two_lists = URITemplate::RFC6570.new('{listA*,listB*}')
  #   uri = two_lists.expand('listA'=>[1,2],'listB'=>[3,4]) #=> "1,2,3,4"
  #   variables = two_lists.extract( uri ) #=> {'listA'=>["1","2","3"],'listB'=>["4"]}
  #   # However, like said in the note:
  #   two_lists.expand( variables ) == uri #=> true
  # @note Don't expect that an extraction can fully recover the expanded variables. Extract rather generates a variable list which should expand to the uri from which it were extracted. In general the following equation should hold true:
  #   a_tpl.expand( a_tpl.extract( an_uri ) ) == an_uri
  # @note The current implementation drops duplicated variables instead of checking them.
  # @param uri_or_match [String, MatchData] Uri_or_MatchData A uri or a matchdata from which the variables should be extracted.
  # @param post_processing [Array] Processing Specifies which processing should be done.
  # @raise Encoding::InvalidByteSequenceError when the given uri was not properly encoded.
  # @raise Encoding::UndefinedConversionError when the given uri could not be converted to utf-8.
  # @raise Encoding::CompatibilityError when the given uri could not be converted to utf-8.
  #
  # source://uri_template//lib/uri_template/rfc6570.rb#387
  def extract(uri_or_match, post_processing = T.unsafe(nil)); end

  # Extracts variables without any proccessing.
  # This is equivalent to {#extract} with options {NO_PROCESSING}.
  #
  # @see #extract
  #
  # source://uri_template//lib/uri_template/rfc6570.rb#414
  def extract_simple(uri_or_match); end

  # Returns the level of this template according to the rfc 6570 ( http://tools.ietf.org/html/rfc6570#section-1.2 ). Higher level means higher complexity.
  # Basically this is defined as:
  #
  # * Level 1: no operators, one variable per expansion, no variable modifiers
  # * Level 2: '+' and '#' operators, one variable per expansion, no variable modifiers
  # * Level 3: all operators, multiple variables per expansion, no variable modifiers
  # * Level 4: all operators, multiple variables per expansion, all variable modifiers
  #
  # Templates of lower levels might be convertible to other formats while templates of higher levels might be incompatible. Level 1 for example should be convertible to any other format since it just contains simple expansions.
  #
  # @example
  #   URITemplate::RFC6570.new('/foo/').level #=> 1
  #   URITemplate::RFC6570.new('/foo{bar}').level #=> 1
  #   URITemplate::RFC6570.new('/foo{#bar}').level #=> 2
  #   URITemplate::RFC6570.new('/foo{.bar}').level #=> 3
  #   URITemplate::RFC6570.new('/foo{bar,baz}').level #=> 3
  #   URITemplate::RFC6570.new('/foo{bar:20}').level #=> 4
  #   URITemplate::RFC6570.new('/foo{bar*}').level #=> 4
  #
  # source://uri_template//lib/uri_template/rfc6570.rb#460
  def level; end

  # Alias for to_r.match . Matches this template against the given uri.
  #
  # @return MatchData, Object
  # @yield MatchData
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def match(*args, **_arg1, &block); end

  # Returns the value of attribute options.
  #
  # source://uri_template//lib/uri_template/rfc6570.rb#289
  def options; end

  # Compiles this template into a regular expression which can be used to test whether a given uri matches this template. This template is also used for {#===}.
  #
  # @example
  #   tpl = URITemplate::RFC6570.new('/foo/{bar}/')
  #   regex = tpl.to_r
  #   regex === '/foo/baz/' #=> true
  #   regex === '/foz/baz/' #=> false
  # @return Regexp
  #
  # source://uri_template//lib/uri_template/rfc6570.rb#343
  def to_r; end

  # Returns an array containing a the template tokens.
  #
  # source://uri_template//lib/uri_template/rfc6570.rb#465
  def tokens; end

  # The type of this template.
  #
  # @example
  #   tpl1 = URITemplate::RFC6570.new('/foo')
  #   tpl2 = URITemplate.new( tpl1.pattern, tpl1.type )
  #   tpl1 == tpl2 #=> true
  # @see {URITemplate#type}
  #
  # source://uri_template//lib/uri_template/rfc6570.rb#437
  def type; end

  protected

  # @private
  #
  # source://uri_template//lib/uri_template/rfc6570.rb#476
  def extract_matchdata(matchdata, post_processing); end

  # @private
  #
  # source://uri_template//lib/uri_template/rfc6570.rb#471
  def tokenize!; end
end

# @private
#
# source://uri_template//lib/uri_template/rfc6570.rb#90
URITemplate::RFC6570::CHARACTER_CLASSES = T.let(T.unsafe(nil), Hash)

# Specifies that the extracted variable list should be processed.
#
# @see #extract
#
# source://uri_template//lib/uri_template/rfc6570.rb#122
URITemplate::RFC6570::CONVERT_RESULT = T.let(T.unsafe(nil), Array)

# Specifies that the extracted values should be processed.
#
# @see #extract
#
# source://uri_template//lib/uri_template/rfc6570.rb#118
URITemplate::RFC6570::CONVERT_VALUES = T.let(T.unsafe(nil), Array)

# The class methods for all rfc6570 templates.
#
# source://uri_template//lib/uri_template/rfc6570.rb#243
module URITemplate::RFC6570::ClassMethods
  # Tries to convert the given param in to a instance of {RFC6570}
  # It basically passes thru instances of that class, parses strings and return nil on everything else.
  #
  # @example
  #   URITemplate::RFC6570.try_convert( Object.new ) #=> nil
  #   tpl = URITemplate::RFC6570.new('{foo}')
  #   URITemplate::RFC6570.try_convert( tpl ) #=> tpl
  #   URITemplate::RFC6570.try_convert('{foo}') #=> tpl
  #   URITemplate::RFC6570.try_convert(URITemplate.new(:colon, ':foo')) #=> tpl
  #   # This pattern is invalid, so it wont be parsed:
  #   URITemplate::RFC6570.try_convert('{foo') #=> nil
  #
  # source://uri_template//lib/uri_template/rfc6570.rb#257
  def try_convert(x); end

  # Tests whether a given pattern is a valid template pattern.
  #
  # @example
  #   URITemplate::RFC6570.valid? 'foo' #=> true
  #   URITemplate::RFC6570.valid? '{foo}' #=> true
  #   URITemplate::RFC6570.valid? '{foo' #=> false
  # @return [Boolean]
  #
  # source://uri_template//lib/uri_template/rfc6570.rb#281
  def valid?(pattern); end
end

# Default processing. Means: convert values and the list itself.
#
# @see #extract
#
# source://uri_template//lib/uri_template/rfc6570.rb#126
URITemplate::RFC6570::DEFAULT_PROCESSING = T.let(T.unsafe(nil), Array)

# @private
#
# source://uri_template//lib/uri_template/rfc6570.rb#140
URITemplate::RFC6570::EXPRESSION = T.let(T.unsafe(nil), Regexp)

# @private
#
# source://uri_template//lib/uri_template/rfc6570/expression.rb#28
class URITemplate::RFC6570::Expression < ::URITemplate::RFC6570::Token
  include ::URITemplate::Token
  include ::URITemplate::Expression
  extend ::URITemplate::RFC6570::Expression::ClassMethods

  # @return [Expression] a new instance of Expression
  #
  # source://uri_template//lib/uri_template/rfc6570/expression.rb#34
  def initialize(vars); end

  # source://uri_template//lib/uri_template/rfc6570/expression.rb#63
  def arity; end

  # source://uri_template//lib/uri_template/rfc6570/expression.rb#67
  def expand(vars); end

  # source://uri_template//lib/uri_template/rfc6570/expression.rb#81
  def expand_partial(vars); end

  # source://uri_template//lib/uri_template/rfc6570/expression.rb#112
  def extract(position, matched); end

  # source://uri_template//lib/uri_template/rfc6570/expression.rb#51
  def level; end

  # source://uri_template//lib/uri_template/rfc6570/expression.rb#133
  def to_s; end

  # Returns the value of attribute variables.
  #
  # source://uri_template//lib/uri_template/rfc6570/expression.rb#32
  def variables; end

  protected

  # source://uri_template//lib/uri_template/rfc6570/expression.rb#244
  def cut(str, chars); end

  # source://uri_template//lib/uri_template/rfc6570/expression.rb#217
  def decode(x, split = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://uri_template//lib/uri_template/rfc6570/expression.rb#283
  def empty_literals?(list); end

  # source://uri_template//lib/uri_template/rfc6570/expression.rb#201
  def escape(x); end

  # source://uri_template//lib/uri_template/rfc6570/expression.rb#253
  def pair(key, value, max_length = T.unsafe(nil), &block); end

  # source://uri_template//lib/uri_template/rfc6570/expression.rb#209
  def regex_builder; end

  # source://uri_template//lib/uri_template/rfc6570/expression.rb#275
  def transform_array(name, ary, expand, max_length); end

  # source://uri_template//lib/uri_template/rfc6570/expression.rb#267
  def transform_hash(name, hsh, expand, max_length); end

  # source://uri_template//lib/uri_template/rfc6570/expression.rb#205
  def unescape(x); end

  private

  # source://uri_template//lib/uri_template/rfc6570/expression.rb#139
  def expand_one(name, value, expand, max_length); end

  # source://uri_template//lib/uri_template/rfc6570/expression.rb#153
  def extracted_nil; end

  # @return [Boolean]
  #
  # source://uri_template//lib/uri_template/rfc6570/expression.rb#149
  def length_limited?(max_length); end
end

# source://uri_template//lib/uri_template/rfc6570/expression.rb#45
URITemplate::RFC6570::Expression::BASE_LEVEL = T.let(T.unsafe(nil), Integer)

# source://uri_template//lib/uri_template/rfc6570/expression.rb#291
class URITemplate::RFC6570::Expression::Basic < ::URITemplate::RFC6570::Expression::Unnamed; end

# source://uri_template//lib/uri_template/rfc6570/expression.rb#293
URITemplate::RFC6570::Expression::Basic::BULK_FOLLOW_UP = URITemplate::RFC6570::Expression::Basic

# source://uri_template//lib/uri_template/rfc6570/expression.rb#292
URITemplate::RFC6570::Expression::Basic::FOLLOW_UP = URITemplate::RFC6570::Expression::Basic

# source://uri_template//lib/uri_template/rfc6570/expression.rb#47
URITemplate::RFC6570::Expression::CHARACTER_CLASS = T.let(T.unsafe(nil), Hash)

# source://uri_template//lib/uri_template/rfc6570/expression.rb#215
URITemplate::RFC6570::Expression::COMMA = T.let(T.unsafe(nil), String)

# source://uri_template//lib/uri_template/rfc6570/expression.rb#159
module URITemplate::RFC6570::Expression::ClassMethods
  # source://uri_template//lib/uri_template/rfc6570/expression.rb#169
  def generate_hash_extractor(max_length); end

  # source://uri_template//lib/uri_template/rfc6570/expression.rb#165
  def hash_extractor(max_length); end

  # source://uri_template//lib/uri_template/rfc6570/expression.rb#161
  def hash_extractors; end

  # source://uri_template//lib/uri_template/rfc6570/expression.rb#193
  def regex_builder; end
end

# source://uri_template//lib/uri_template/rfc6570/expression.rb#389
class URITemplate::RFC6570::Expression::FormQuery < ::URITemplate::RFC6570::Expression::Named; end

# source://uri_template//lib/uri_template/rfc6570/expression.rb#394
URITemplate::RFC6570::Expression::FormQuery::BASE_LEVEL = T.let(T.unsafe(nil), Integer)

# source://uri_template//lib/uri_template/rfc6570/expression.rb#396
URITemplate::RFC6570::Expression::FormQuery::BULK_FOLLOW_UP = URITemplate::RFC6570::Expression::FormQueryContinuation

# source://uri_template//lib/uri_template/rfc6570/expression.rb#395
URITemplate::RFC6570::Expression::FormQuery::FOLLOW_UP = URITemplate::RFC6570::Expression::Basic

# source://uri_template//lib/uri_template/rfc6570/expression.rb#393
URITemplate::RFC6570::Expression::FormQuery::OPERATOR = T.let(T.unsafe(nil), String)

# source://uri_template//lib/uri_template/rfc6570/expression.rb#392
URITemplate::RFC6570::Expression::FormQuery::PREFIX = T.let(T.unsafe(nil), String)

# source://uri_template//lib/uri_template/rfc6570/expression.rb#391
URITemplate::RFC6570::Expression::FormQuery::SEPARATOR = T.let(T.unsafe(nil), String)

# source://uri_template//lib/uri_template/rfc6570/expression.rb#379
class URITemplate::RFC6570::Expression::FormQueryContinuation < ::URITemplate::RFC6570::Expression::Named; end

# source://uri_template//lib/uri_template/rfc6570/expression.rb#384
URITemplate::RFC6570::Expression::FormQueryContinuation::BASE_LEVEL = T.let(T.unsafe(nil), Integer)

# source://uri_template//lib/uri_template/rfc6570/expression.rb#386
URITemplate::RFC6570::Expression::FormQueryContinuation::BULK_FOLLOW_UP = URITemplate::RFC6570::Expression::FormQueryContinuation

# source://uri_template//lib/uri_template/rfc6570/expression.rb#385
URITemplate::RFC6570::Expression::FormQueryContinuation::FOLLOW_UP = URITemplate::RFC6570::Expression::Basic

# source://uri_template//lib/uri_template/rfc6570/expression.rb#383
URITemplate::RFC6570::Expression::FormQueryContinuation::OPERATOR = T.let(T.unsafe(nil), String)

# source://uri_template//lib/uri_template/rfc6570/expression.rb#382
URITemplate::RFC6570::Expression::FormQueryContinuation::PREFIX = T.let(T.unsafe(nil), String)

# source://uri_template//lib/uri_template/rfc6570/expression.rb#381
URITemplate::RFC6570::Expression::FormQueryContinuation::SEPARATOR = T.let(T.unsafe(nil), String)

# source://uri_template//lib/uri_template/rfc6570/expression.rb#322
class URITemplate::RFC6570::Expression::Fragment < ::URITemplate::RFC6570::Expression::Unnamed
  # source://uri_template//lib/uri_template/rfc6570/expression.rb#331
  def escape(x); end

  # source://uri_template//lib/uri_template/rfc6570/expression.rb#335
  def unescape(x); end
end

# source://uri_template//lib/uri_template/rfc6570/expression.rb#327
URITemplate::RFC6570::Expression::Fragment::BASE_LEVEL = T.let(T.unsafe(nil), Integer)

# source://uri_template//lib/uri_template/rfc6570/expression.rb#329
URITemplate::RFC6570::Expression::Fragment::BULK_FOLLOW_UP = URITemplate::RFC6570::Expression::Reserved

# source://uri_template//lib/uri_template/rfc6570/expression.rb#324
URITemplate::RFC6570::Expression::Fragment::CHARACTER_CLASS = T.let(T.unsafe(nil), Hash)

# source://uri_template//lib/uri_template/rfc6570/expression.rb#328
URITemplate::RFC6570::Expression::Fragment::FOLLOW_UP = URITemplate::RFC6570::Expression::Reserved

# source://uri_template//lib/uri_template/rfc6570/expression.rb#326
URITemplate::RFC6570::Expression::Fragment::OPERATOR = T.let(T.unsafe(nil), String)

# source://uri_template//lib/uri_template/rfc6570/expression.rb#325
URITemplate::RFC6570::Expression::Fragment::PREFIX = T.let(T.unsafe(nil), String)

# source://uri_template//lib/uri_template/rfc6570/expression.rb#44
URITemplate::RFC6570::Expression::LIST_CONNECTOR = T.let(T.unsafe(nil), String)

# source://uri_template//lib/uri_template/rfc6570/expression.rb#341
class URITemplate::RFC6570::Expression::Label < ::URITemplate::RFC6570::Expression::Unnamed; end

# source://uri_template//lib/uri_template/rfc6570/expression.rb#346
URITemplate::RFC6570::Expression::Label::BASE_LEVEL = T.let(T.unsafe(nil), Integer)

# source://uri_template//lib/uri_template/rfc6570/expression.rb#348
URITemplate::RFC6570::Expression::Label::BULK_FOLLOW_UP = URITemplate::RFC6570::Expression::Label

# source://uri_template//lib/uri_template/rfc6570/expression.rb#347
URITemplate::RFC6570::Expression::Label::FOLLOW_UP = URITemplate::RFC6570::Expression::Label

# source://uri_template//lib/uri_template/rfc6570/expression.rb#345
URITemplate::RFC6570::Expression::Label::OPERATOR = T.let(T.unsafe(nil), String)

# source://uri_template//lib/uri_template/rfc6570/expression.rb#344
URITemplate::RFC6570::Expression::Label::PREFIX = T.let(T.unsafe(nil), String)

# source://uri_template//lib/uri_template/rfc6570/expression.rb#343
URITemplate::RFC6570::Expression::Label::SEPARATOR = T.let(T.unsafe(nil), String)

# source://uri_template//lib/uri_template/rfc6570/expression/named.rb#28
class URITemplate::RFC6570::Expression::Named < ::URITemplate::RFC6570::Expression
  # source://uri_template//lib/uri_template/rfc6570/expression/named.rb#65
  def expand_partial(vars); end

  # source://uri_template//lib/uri_template/rfc6570/expression/named.rb#32
  def to_r_source; end

  protected

  # source://uri_template//lib/uri_template/rfc6570/expression.rb#253
  def self_pair(key, value, max_length = T.unsafe(nil), &block); end

  private

  # source://uri_template//lib/uri_template/rfc6570/expression/named.rb#104
  def after_expand(name, splitted); end

  # source://uri_template//lib/uri_template/rfc6570/expression/named.rb#100
  def extracted_nil; end
end

# source://uri_template//lib/uri_template/rfc6570/expression.rb#49
URITemplate::RFC6570::Expression::OPERATOR = T.let(T.unsafe(nil), String)

# source://uri_template//lib/uri_template/rfc6570/expression.rb#42
URITemplate::RFC6570::Expression::PAIR_CONNECTOR = T.let(T.unsafe(nil), String)

# source://uri_template//lib/uri_template/rfc6570/expression.rb#43
URITemplate::RFC6570::Expression::PAIR_IF_EMPTY = T.let(T.unsafe(nil), TrueClass)

# source://uri_template//lib/uri_template/rfc6570/expression.rb#40
URITemplate::RFC6570::Expression::PREFIX = T.let(T.unsafe(nil), String)

# source://uri_template//lib/uri_template/rfc6570/expression.rb#352
class URITemplate::RFC6570::Expression::Path < ::URITemplate::RFC6570::Expression::Unnamed
  # @return [Boolean]
  #
  # source://uri_template//lib/uri_template/rfc6570/expression.rb#361
  def starts_with_slash?; end
end

# source://uri_template//lib/uri_template/rfc6570/expression.rb#357
URITemplate::RFC6570::Expression::Path::BASE_LEVEL = T.let(T.unsafe(nil), Integer)

# source://uri_template//lib/uri_template/rfc6570/expression.rb#359
URITemplate::RFC6570::Expression::Path::BULK_FOLLOW_UP = URITemplate::RFC6570::Expression::Path

# source://uri_template//lib/uri_template/rfc6570/expression.rb#358
URITemplate::RFC6570::Expression::Path::FOLLOW_UP = URITemplate::RFC6570::Expression::Path

# source://uri_template//lib/uri_template/rfc6570/expression.rb#356
URITemplate::RFC6570::Expression::Path::OPERATOR = T.let(T.unsafe(nil), String)

# source://uri_template//lib/uri_template/rfc6570/expression.rb#355
URITemplate::RFC6570::Expression::Path::PREFIX = T.let(T.unsafe(nil), String)

# source://uri_template//lib/uri_template/rfc6570/expression.rb#354
URITemplate::RFC6570::Expression::Path::SEPARATOR = T.let(T.unsafe(nil), String)

# source://uri_template//lib/uri_template/rfc6570/expression.rb#367
class URITemplate::RFC6570::Expression::PathParameters < ::URITemplate::RFC6570::Expression::Named; end

# source://uri_template//lib/uri_template/rfc6570/expression.rb#373
URITemplate::RFC6570::Expression::PathParameters::BASE_LEVEL = T.let(T.unsafe(nil), Integer)

# source://uri_template//lib/uri_template/rfc6570/expression.rb#375
URITemplate::RFC6570::Expression::PathParameters::BULK_FOLLOW_UP = URITemplate::RFC6570::Expression::PathParameters

# source://uri_template//lib/uri_template/rfc6570/expression.rb#374
URITemplate::RFC6570::Expression::PathParameters::FOLLOW_UP = URITemplate::RFC6570::Expression::PathParameters

# source://uri_template//lib/uri_template/rfc6570/expression.rb#372
URITemplate::RFC6570::Expression::PathParameters::OPERATOR = T.let(T.unsafe(nil), String)

# source://uri_template//lib/uri_template/rfc6570/expression.rb#371
URITemplate::RFC6570::Expression::PathParameters::PAIR_IF_EMPTY = T.let(T.unsafe(nil), FalseClass)

# source://uri_template//lib/uri_template/rfc6570/expression.rb#370
URITemplate::RFC6570::Expression::PathParameters::PREFIX = T.let(T.unsafe(nil), String)

# source://uri_template//lib/uri_template/rfc6570/expression.rb#369
URITemplate::RFC6570::Expression::PathParameters::SEPARATOR = T.let(T.unsafe(nil), String)

# source://uri_template//lib/uri_template/rfc6570/expression.rb#296
class URITemplate::RFC6570::Expression::Reserved < ::URITemplate::RFC6570::Expression::Unnamed
  # source://uri_template//lib/uri_template/rfc6570/expression.rb#304
  def escape(x); end

  # @return [Boolean]
  #
  # source://uri_template//lib/uri_template/rfc6570/expression.rb#316
  def host?; end

  # @return [Boolean]
  #
  # source://uri_template//lib/uri_template/rfc6570/expression.rb#312
  def scheme?; end

  # source://uri_template//lib/uri_template/rfc6570/expression.rb#308
  def unescape(x); end
end

# source://uri_template//lib/uri_template/rfc6570/expression.rb#300
URITemplate::RFC6570::Expression::Reserved::BASE_LEVEL = T.let(T.unsafe(nil), Integer)

# source://uri_template//lib/uri_template/rfc6570/expression.rb#302
URITemplate::RFC6570::Expression::Reserved::BULK_FOLLOW_UP = URITemplate::RFC6570::Expression::Reserved

# source://uri_template//lib/uri_template/rfc6570/expression.rb#298
URITemplate::RFC6570::Expression::Reserved::CHARACTER_CLASS = T.let(T.unsafe(nil), Hash)

# source://uri_template//lib/uri_template/rfc6570/expression.rb#301
URITemplate::RFC6570::Expression::Reserved::FOLLOW_UP = URITemplate::RFC6570::Expression::Reserved

# source://uri_template//lib/uri_template/rfc6570/expression.rb#299
URITemplate::RFC6570::Expression::Reserved::OPERATOR = T.let(T.unsafe(nil), String)

# source://uri_template//lib/uri_template/rfc6570/expression.rb#41
URITemplate::RFC6570::Expression::SEPARATOR = T.let(T.unsafe(nil), String)

# source://uri_template//lib/uri_template/rfc6570/expression.rb#213
URITemplate::RFC6570::Expression::SPLITTER = T.let(T.unsafe(nil), Regexp)

# source://uri_template//lib/uri_template/rfc6570/expression/unnamed.rb#26
class URITemplate::RFC6570::Expression::Unnamed < ::URITemplate::RFC6570::Expression
  # source://uri_template//lib/uri_template/rfc6570/expression/unnamed.rb#28
  def self_pair(_, value, max_length = T.unsafe(nil), &block); end

  # source://uri_template//lib/uri_template/rfc6570/expression/unnamed.rb#37
  def to_r_source; end

  private

  # source://uri_template//lib/uri_template/rfc6570/expression/unnamed.rb#84
  def after_expand(name, splitted); end

  # source://uri_template//lib/uri_template/rfc6570/expression/unnamed.rb#79
  def transform_array(name, ary, expand, max_length); end

  # source://uri_template//lib/uri_template/rfc6570/expression/unnamed.rb#74
  def transform_hash(name, hsh, expand, max_length); end
end

# This error is raised when an invalid pattern was given.
#
# source://uri_template//lib/uri_template/rfc6570.rb#190
class URITemplate::RFC6570::Invalid < ::StandardError
  include ::URITemplate::Invalid

  # @return [Invalid] a new instance of Invalid
  #
  # source://uri_template//lib/uri_template/rfc6570.rb#196
  def initialize(source, position); end

  # Returns the value of attribute pattern.
  #
  # source://uri_template//lib/uri_template/rfc6570.rb#194
  def pattern; end

  # Returns the value of attribute position.
  #
  # source://uri_template//lib/uri_template/rfc6570.rb#194
  def position; end
end

# @private
#
# source://uri_template//lib/uri_template/rfc6570.rb#82
URITemplate::RFC6570::LITERAL = T.let(T.unsafe(nil), Regexp)

# @private
#
# source://uri_template//lib/uri_template/rfc6570.rb#167
class URITemplate::RFC6570::Literal < ::URITemplate::RFC6570::Token
  include ::URITemplate::Token
  include ::URITemplate::Literal

  # @return [Literal] a new instance of Literal
  #
  # source://uri_template//lib/uri_template/rfc6570.rb#171
  def initialize(string); end

  # source://uri_template//lib/uri_template/rfc6570.rb#175
  def level; end

  # source://uri_template//lib/uri_template/rfc6570.rb#179
  def to_r_source(*_); end

  # source://uri_template//lib/uri_template/rfc6570.rb#183
  def to_s; end
end

# Specifies that no processing should be done upon extraction.
#
# @see #extract
#
# source://uri_template//lib/uri_template/rfc6570.rb#114
URITemplate::RFC6570::NO_PROCESSING = T.let(T.unsafe(nil), Array)

# @private
#
# source://uri_template//lib/uri_template/rfc6570/expression.rb#402
URITemplate::RFC6570::OPERATORS = T.let(T.unsafe(nil), Hash)

# source://uri_template//lib/uri_template/rfc6570/regex_builder.rb#28
class URITemplate::RFC6570::RegexBuilder
  # @return [RegexBuilder] a new instance of RegexBuilder
  #
  # source://uri_template//lib/uri_template/rfc6570/regex_builder.rb#30
  def initialize(expression_class); end

  # source://uri_template//lib/uri_template/rfc6570/regex_builder.rb#35
  def <<(arg); end

  # source://uri_template//lib/uri_template/rfc6570/regex_builder.rb#96
  def capture(&block); end

  # source://uri_template//lib/uri_template/rfc6570/regex_builder.rb#69
  def character_class(max_length = T.unsafe(nil), min = T.unsafe(nil)); end

  # source://uri_template//lib/uri_template/rfc6570/regex_builder.rb#65
  def character_class_with_comma(max_length = T.unsafe(nil), min = T.unsafe(nil)); end

  # source://uri_template//lib/uri_template/rfc6570/regex_builder.rb#45
  def escaped_pair_connector; end

  # source://uri_template//lib/uri_template/rfc6570/regex_builder.rb#53
  def escaped_prefix; end

  # source://uri_template//lib/uri_template/rfc6570/regex_builder.rb#49
  def escaped_separator; end

  # source://uri_template//lib/uri_template/rfc6570/regex_builder.rb#77
  def group(capture = T.unsafe(nil)); end

  # source://uri_template//lib/uri_template/rfc6570/regex_builder.rb#57
  def join; end

  # source://uri_template//lib/uri_template/rfc6570/regex_builder.rb#61
  def length(*args); end

  # source://uri_template//lib/uri_template/rfc6570/regex_builder.rb#90
  def lookahead; end

  # source://uri_template//lib/uri_template/rfc6570/regex_builder.rb#84
  def negative_lookahead; end

  # source://uri_template//lib/uri_template/rfc6570/regex_builder.rb#40
  def push(*args); end

  # source://uri_template//lib/uri_template/rfc6570/regex_builder.rb#73
  def reluctant; end

  # source://uri_template//lib/uri_template/rfc6570/regex_builder.rb#100
  def separated_list(first = T.unsafe(nil), length = T.unsafe(nil), min = T.unsafe(nil), &block); end

  private

  # source://uri_template//lib/uri_template/rfc6570/regex_builder.rb#112
  def format_length(len, min = T.unsafe(nil)); end
end

# source://uri_template//lib/uri_template/rfc6570.rb#36
URITemplate::RFC6570::TYPE = T.let(T.unsafe(nil), Symbol)

# @private
#
# source://uri_template//lib/uri_template/rfc6570.rb#163
class URITemplate::RFC6570::Token; end

# @private
#
# source://uri_template//lib/uri_template/rfc6570.rb#205
class URITemplate::RFC6570::Tokenizer
  include ::Enumerable

  # @return [Tokenizer] a new instance of Tokenizer
  #
  # source://uri_template//lib/uri_template/rfc6570.rb#211
  def initialize(source, ops); end

  # source://uri_template//lib/uri_template/rfc6570.rb#216
  def each; end

  # Returns the value of attribute source.
  #
  # source://uri_template//lib/uri_template/rfc6570.rb#209
  def source; end
end

# @private
#
# source://uri_template//lib/uri_template/rfc6570.rb#158
URITemplate::RFC6570::URI = T.let(T.unsafe(nil), Regexp)

# @private
#
# source://uri_template//lib/uri_template/rfc6570.rb#42
module URITemplate::RFC6570::Utils
  include ::URITemplate::Utils::StringEncoding::Encode
  include ::URITemplate::Utils::StringEncoding
  include ::URITemplate::Utils::Escaping::Pure
  include ::URITemplate::Utils
  extend ::URITemplate::Utils::StringEncoding::Encode
  extend ::URITemplate::Utils::StringEncoding
  extend ::URITemplate::Utils::Escaping::Pure
  extend ::URITemplate::Utils
  extend ::URITemplate::RFC6570::Utils

  # Returns true iff the value is `defined` [RFC6570 Section 2.3](http://tools.ietf.org/html/rfc6570#section-2.3)
  #
  # The only undefined things are:
  # - nil
  # - arrays containing no defined value
  # - associative arrays/hashes containing no defined value
  #
  # Things that are always defined:
  # - Strings, independent of the length
  #
  # @return [Boolean]
  #
  # source://uri_template//lib/uri_template/rfc6570.rb#55
  def def?(value); end
end

# @private
#
# source://uri_template//lib/uri_template/rfc6570.rb#129
URITemplate::RFC6570::VAR = T.let(T.unsafe(nil), Regexp)

# An awesome little helper which helps iterating over a string.
# Initialize with a regexp and pass a string to :each.
# It will yield a string or a MatchData
#
# source://uri_template//lib/uri_template/utils.rb#29
class URITemplate::RegexpEnumerator
  include ::Enumerable

  # @return [RegexpEnumerator] a new instance of RegexpEnumerator
  #
  # source://uri_template//lib/uri_template/utils.rb#33
  def initialize(regexp, options = T.unsafe(nil)); end

  # @raise [ArgumentError]
  #
  # source://uri_template//lib/uri_template/utils.rb#38
  def each(str); end
end

# @api private
#
# source://uri_template//lib/uri_template.rb#64
URITemplate::SCHEME_REGEX = T.let(T.unsafe(nil), Regexp)

# This should make it possible to do basic analysis independently from the concrete type.
# Usually the submodules {URITemplate::Literal} and {URITemplate::Expression} are used.
#
# @abstract
#
# source://uri_template//lib/uri_template/token.rb#28
module URITemplate::Token
  # @return [Boolean]
  #
  # source://uri_template//lib/uri_template/token.rb#48
  def ends_with_slash?; end

  # @abstract
  #
  # source://uri_template//lib/uri_template/token.rb#61
  def expand(variables); end

  # @abstract
  #
  # source://uri_template//lib/uri_template/token.rb#66
  def expand_partial(variables); end

  # @return [Boolean]
  #
  # source://uri_template//lib/uri_template/token.rb#56
  def host?; end

  # @return [Boolean]
  #
  # source://uri_template//lib/uri_template/token.rb#52
  def scheme?; end

  # Number of variables in this token
  #
  # source://uri_template//lib/uri_template/token.rb#40
  def size; end

  # @return [Boolean]
  #
  # source://uri_template//lib/uri_template/token.rb#44
  def starts_with_slash?; end

  # @abstract
  #
  # source://uri_template//lib/uri_template/token.rb#71
  def to_s; end

  # The variable names used in this token.
  #
  # @return [Array<String>]
  #
  # source://uri_template//lib/uri_template/token.rb#35
  def variables; end
end

# source://uri_template//lib/uri_template/token.rb#30
URITemplate::Token::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# @api private
#
# source://uri_template//lib/uri_template.rb#70
URITemplate::URI_SPLIT = T.let(T.unsafe(nil), Regexp)

# This error will be raised whenever an object could not be converted to a param string.
#
# source://uri_template//lib/uri_template/utils.rb#69
class URITemplate::Unconvertable < ::StandardError
  # @return [Unconvertable] a new instance of Unconvertable
  #
  # source://uri_template//lib/uri_template/utils.rb#73
  def initialize(object); end

  # Returns the value of attribute object.
  #
  # source://uri_template//lib/uri_template/utils.rb#71
  def object; end
end

# A collection of some utility methods.
# The most methods are used to parse or generate uri-parameters.
# I will use the escape_utils library if available, but runs happily without.
#
# source://uri_template//lib/uri_template/utils.rb#84
module URITemplate::Utils
  include ::URITemplate::Utils::StringEncoding::Encode
  include ::URITemplate::Utils::StringEncoding
  include ::URITemplate::Utils::Escaping::Pure
  extend ::URITemplate::Utils::StringEncoding::Encode
  extend ::URITemplate::Utils::StringEncoding
  extend ::URITemplate::Utils::Escaping::Pure
  extend ::URITemplate::Utils

  # @api private
  #
  # source://uri_template//lib/uri_template/utils.rb#328
  def compact_regexp(rx); end

  # Converts an object to a param value.
  # Tries to call :to_param and then :to_s on that object.
  #
  # @example
  #   URITemplate::Utils.object_to_param(5) #=> "5"
  #   o = Object.new
  #   def o.to_param
  #   "42"
  #   end
  #   URITemplate::Utils.object_to_param(o) #=> "42"
  # @raise Unconvertable if the object could not be converted.
  #
  # source://uri_template//lib/uri_template/utils.rb#253
  def object_to_param(object); end

  # Returns true when the given value is an array and it only consists of arrays with two items.
  # This useful when using a hash is not ideal, since it doesn't allow duplicate keys.
  #
  # @example
  #   URITemplate::Utils.pair_array?( Object.new ) #=> false
  #   URITemplate::Utils.pair_array?( [] ) #=> true
  #   URITemplate::Utils.pair_array?( [1,2,3] ) #=> false
  #   URITemplate::Utils.pair_array?( [ ['a',1],['b',2],['c',3] ] ) #=> true
  #   URITemplate::Utils.pair_array?( [ ['a',1],['b',2],['c',3],[] ] ) #=> false
  # @return [Boolean]
  #
  # source://uri_template//lib/uri_template/utils.rb#279
  def pair_array?(a); end

  # Turns the given value into a hash if it is an array of pairs.
  # Otherwise it returns the value.
  # You can test whether a value will be converted with {#pair_array?}.
  #
  # @example
  #   URITemplate::Utils.pair_array_to_hash( 'x' ) #=> 'x'
  #   URITemplate::Utils.pair_array_to_hash( [ ['a',1],['b',2],['c',3] ] ) #=> {'a'=>1,'b'=>2,'c'=>3}
  #   URITemplate::Utils.pair_array_to_hash( [ ['a',1],['a',2],['a',3] ] ) #=> {'a'=>3}
  # @example Carful vs. Ignorant
  #   URITemplate::Utils.pair_array_to_hash( [ ['a',1],'foo','bar'], false ) #UNDEFINED!
  #   URITemplate::Utils.pair_array_to_hash( [ ['a',1],'foo','bar'], true )  #=> [ ['a',1], 'foo', 'bar']
  # @param x the value to convert
  # @param careful [true, false] wheter to check every array item. Use this when you expect array with subarrays which are not pairs. Setting this to false however improves runtime by ~30% even with comparetivly short arrays.
  #
  # source://uri_template//lib/uri_template/utils.rb#299
  def pair_array_to_hash(x, careful = T.unsafe(nil)); end

  # @api privat
  #
  # source://uri_template//lib/uri_template/utils.rb#310
  def pair_array_to_hash2(x); end

  # Should we use \u.... or \x.. in regexps?
  #
  # @api private
  # @return [Boolean]
  #
  # source://uri_template//lib/uri_template/utils.rb#267
  def use_unicode?; end
end

# source://uri_template//lib/uri_template/utils.rb#153
module URITemplate::Utils::Escaping; end

# A pure escaping module, which implements escaping methods in pure ruby.
# The performance is acceptable, but could be better with escape_utils.
#
# source://uri_template//lib/uri_template/utils.rb#157
module URITemplate::Utils::Escaping::Pure
  # source://uri_template//lib/uri_template/utils.rb#174
  def escape_uri(s); end

  # source://uri_template//lib/uri_template/utils.rb#168
  def escape_url(s); end

  # source://uri_template//lib/uri_template/utils.rb#186
  def unescape_uri(s); end

  # source://uri_template//lib/uri_template/utils.rb#180
  def unescape_url(s); end

  # @return [Boolean]
  #
  # source://uri_template//lib/uri_template/utils.rb#192
  def using_escape_utils?; end
end

# @private
#
# source://uri_template//lib/uri_template/utils.rb#166
URITemplate::Utils::Escaping::Pure::PCT = T.let(T.unsafe(nil), Regexp)

# @private
#
# source://uri_template//lib/uri_template/utils.rb#163
URITemplate::Utils::Escaping::Pure::URI_ESCAPED = T.let(T.unsafe(nil), Regexp)

# @private
#
# source://uri_template//lib/uri_template/utils.rb#160
URITemplate::Utils::Escaping::Pure::URL_ESCAPED = T.let(T.unsafe(nil), Regexp)

# source://uri_template//lib/uri_template/utils.rb#86
URITemplate::Utils::KCODE_UTF8 = T.let(T.unsafe(nil), Integer)

# Bundles some string encoding methods.
#
# source://uri_template//lib/uri_template/utils.rb#89
module URITemplate::Utils::StringEncoding
  include ::URITemplate::Utils::StringEncoding::Encode

  private

  # source://uri_template//lib/uri_template/utils.rb#116
  def force_utf8(str); end
end

# Methods which do actual encoding.
#
# source://uri_template//lib/uri_template/utils.rb#92
module URITemplate::Utils::StringEncoding::Encode
  # enforces UTF8 encoding
  #
  # @param str [String]
  # @return String
  #
  # source://uri_template//lib/uri_template/utils.rb#116
  def force_utf8(str); end

  # converts a string to ascii
  #
  # @param str [String]
  # @return String
  #
  # source://uri_template//lib/uri_template/utils.rb#98
  def to_ascii(str); end

  # converts a string to utf8
  #
  # @param str [String]
  # @return String
  #
  # source://uri_template//lib/uri_template/utils.rb#107
  def to_utf8(str); end
end

# Fallback methods to be used in pre 1.9 rubies.
#
# source://uri_template//lib/uri_template/utils.rb#125
module URITemplate::Utils::StringEncoding::Fallback
  # source://uri_template//lib/uri_template/utils.rb#135
  def force_utf8(str); end

  # source://uri_template//lib/uri_template/utils.rb#127
  def to_ascii(str); end

  # source://uri_template//lib/uri_template/utils.rb#131
  def to_utf8(str); end
end

# A hash with all available implementations.
#
# @see resolve_class
#
# source://uri_template//lib/uri_template.rb#81
URITemplate::VERSIONS = T.let(T.unsafe(nil), Hash)
