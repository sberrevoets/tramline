# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `representable` gem.
# Please instead update this file by running `bin/tapioca gem representable`.


# NOTE: this might become a separate class, that's why it's in a separate file.
#
# source://representable//lib/representable/option.rb#3
module Representable
  mixes_in_class_methods ::Representable::Declarative
  mixes_in_class_methods ::Declarative::Heritage::Included
  mixes_in_class_methods ::Declarative::Heritage::Inherited
  mixes_in_class_methods ::Representable::ModuleExtensions
  mixes_in_class_methods ::Representable::ClassMethods
  mixes_in_class_methods ::Representable::ForCollection
  mixes_in_class_methods ::Representable::Represent

  # Sets the attribute representable_attrs
  #
  # @param value the value to set the attribute representable_attrs to.
  #
  # source://representable//lib/representable.rb#30
  def representable_attrs=(_arg0); end

  private

  # Compiles the document going through all properties.
  #
  # source://representable//lib/representable.rb#53
  def create_representation_with(doc, options, format); end

  # source://representable//lib/representable.rb#75
  def normalize_options(user_options: T.unsafe(nil), **options); end

  # source://representable//lib/representable.rb#92
  def representable_attrs; end

  # source://representable//lib/representable.rb#71
  def representable_bindings_for(format, options); end

  # source://representable//lib/representable.rb#61
  def representable_map(options, format); end

  # source://representable//lib/representable.rb#65
  def representable_map!(doc, options, format, method); end

  # source://representable//lib/representable.rb#96
  def representation_wrap(options = T.unsafe(nil)); end

  # source://representable//lib/representable.rb#100
  def represented; end

  # Reads values from +doc+ and sets properties accordingly.
  #
  # source://representable//lib/representable.rb#45
  def update_properties_from(doc, options, format); end

  class << self
    # source://representable//lib/representable/option.rb#16
    def Option(value); end

    # @private
    #
    # source://representable//lib/representable.rb#32
    def included(base); end
  end
end

# source://representable//lib/representable/serializer.rb#50
Representable::As = T.let(T.unsafe(nil), Proc)

# Warning: don't rely on AssignAs/AssignName, i am not sure if i leave that as functions.
#
# source://representable//lib/representable/serializer.rb#53
Representable::AssignAs = T.let(T.unsafe(nil), Proc)

# Deprecation strategy:
# binding.evaluate_option_with_deprecation(:reader, options, :doc)
#   => binding.evaluate_option(:reader, options) # always pass in options.
#
# source://representable//lib/representable/deserializer.rb#9
Representable::AssignFragment = T.let(T.unsafe(nil), Proc)

# source://representable//lib/representable/serializer.rb#54
Representable::AssignName = T.let(T.unsafe(nil), Proc)

# The Binding provides methods to read/write the fragment for one property.
#
# Actually parsing the fragment from the document happens in Binding#read, everything after that is generic.
#
# source://representable//lib/representable/binding.rb#9
class Representable::Binding
  include ::Representable::Binding::Deprecatable
  include ::Representable::Binding::EvaluateOption
  include ::Representable::Binding::Factories
  extend ::Uber::Delegates

  # @return [Binding] a new instance of Binding
  #
  # source://representable//lib/representable/binding.rb#31
  def initialize(definition); end

  # source://representable//lib/representable/binding.rb#69
  def [](name); end

  # Returns the value of attribute cached_representer.
  #
  # source://representable//lib/representable/binding.rb#83
  def cached_representer; end

  # Sets the attribute cached_representer
  #
  # @param value the value to set the attribute cached_representer to.
  #
  # source://representable//lib/representable/binding.rb#83
  def cached_representer=(_arg0); end

  # source://representable//lib/representable/binding.rb#77
  def default_for(value); end

  # Returns the value of attribute getter.
  #
  # source://representable//lib/representable/binding.rb#40
  def getter; end

  # Returns the value of attribute name.
  #
  # source://representable//lib/representable/binding.rb#40
  def name; end

  # Returns the value of attribute setter.
  #
  # source://representable//lib/representable/binding.rb#40
  def setter; end

  # @return [Boolean]
  #
  # source://representable//lib/representable/binding.rb#73
  def skipable_empty_value?(value); end

  private

  # source://representable//lib/representable/binding.rb#96
  def exec_context(options); end

  # source://representable//lib/representable/binding.rb#100
  def parse_pipeline(input, options); end

  # source://representable//lib/representable/binding.rb#104
  def render_pipeline(input, options); end

  # source://representable//lib/representable/binding.rb#90
  def setup_exec_context!; end

  class << self
    # source://representable//lib/representable/binding.rb#27
    def build(definition); end
  end
end

# generics for collection bindings.
#
# source://representable//lib/representable/binding.rb#109
module Representable::Binding::Collection
  # @return [Boolean]
  #
  # source://representable//lib/representable/binding.rb#110
  def skipable_empty_value?(value); end
end

# Single entry points for rendering and parsing a property are #compile_fragment
# and #uncompile_fragment in Mapper.
#
# source://representable//lib/representable/binding.rb#47
module Representable::Binding::Deprecatable
  # Retrieve value and write fragment to the doc.
  #
  # source://representable//lib/representable/binding.rb#49
  def compile_fragment(options); end

  # Parse value from doc and update the model property.
  #
  # source://representable//lib/representable/binding.rb#54
  def uncompile_fragment(options); end
end

# source://representable//lib/representable/binding.rb#60
module Representable::Binding::EvaluateOption
  # source://representable//lib/representable/binding.rb#61
  def evaluate_option(name, input, options); end
end

# source://representable//lib/representable/pipeline_factories.rb#3
module Representable::Binding::Factories
  # i decided not to use polymorphism here for the sake of clarity.
  #
  # source://representable//lib/representable/pipeline_factories.rb#12
  def collect_for(item_functions); end

  # source://representable//lib/representable/pipeline_factories.rb#68
  def default_parse_fragment_functions; end

  # source://representable//lib/representable/pipeline_factories.rb#57
  def default_parse_init_functions; end

  # source://representable//lib/representable/pipeline_factories.rb#91
  def default_post_functions; end

  # source://representable//lib/representable/pipeline_factories.rb#28
  def default_render_fragment_functions; end

  # source://representable//lib/representable/pipeline_factories.rb#44
  def default_render_init_functions; end

  # source://representable//lib/representable/pipeline_factories.rb#19
  def parse_functions; end

  # source://representable//lib/representable/pipeline_factories.rb#4
  def pipeline_for(name, input, options); end

  # DISCUSS: StopOnNil, before collect
  #
  # source://representable//lib/representable/pipeline_factories.rb#24
  def render_functions; end
end

# source://representable//lib/representable/binding.rb#24
class Representable::Binding::FragmentNotFound; end

# source://representable//lib/representable/binding.rb#10
class Representable::Binding::Map < ::Array
  # TODO: Merge with Definitions.
  #
  # source://representable//lib/representable/binding.rb#19
  def <<(binding); end

  # source://representable//lib/representable/binding.rb#11
  def call(method, options); end
end

# Using this module only makes sense with Decorator representers.
#
# source://representable//lib/representable/cached.rb#3
module Representable::Cached
  mixes_in_class_methods ::Representable::Cached::BuildDefinition

  # source://representable//lib/representable/cached.rb#18
  def representable_map(*_arg0); end

  class << self
    # @private
    #
    # source://representable//lib/representable/cached.rb#14
    def included(includer); end
  end
end

# source://representable//lib/representable/cached.rb#4
module Representable::Cached::BuildDefinition
  # source://representable//lib/representable/cached.rb#5
  def build_definition(*_arg0); end
end

# source://representable//lib/representable.rb#113
module Representable::ClassMethods
  # source://representable//lib/representable.rb#114
  def prepare(represented); end
end

# Collect applies a pipeline to each element of input.
#
# source://representable//lib/representable/pipeline.rb#35
class Representable::Collect < ::Representable::Pipeline
  # when stop, the element is skipped. (should that be Skip then?)
  #
  # source://representable//lib/representable/pipeline.rb#37
  def call(input, options); end
end

# source://representable//lib/representable/pipeline.rb#46
class Representable::Collect::Hash < ::Representable::Pipeline
  # source://representable//lib/representable/pipeline.rb#47
  def call(input, options); end
end

# Stores Definitions from ::property. It preserves the adding order (1.9+).
# Same-named properties get overridden, just like in a Hash.
#
# Overwrite definition_class if you need a custom Definition object (helpful when using
# representable in other gems).
#
# source://representable//lib/representable/config.rb#11
class Representable::Config < ::Declarative::Definitions
  # @return [Config] a new instance of Config
  #
  # source://representable//lib/representable/config.rb#12
  def initialize(*_arg0); end

  # FIXME: this is not inherited.
  #
  # source://representable//lib/representable/config.rb#21
  def options; end

  # source://representable//lib/representable/config.rb#17
  def remove(name); end

  # source://representable//lib/representable/config.rb#25
  def wrap=(value); end

  # Computes the wrap string or returns false.
  #
  # source://representable//lib/representable/config.rb#31
  def wrap_for(represented, options = T.unsafe(nil), &block); end

  private

  # source://representable//lib/representable/config.rb#42
  def infer_name_for(name); end
end

# source://representable//lib/representable/deserializer.rb#60
module Representable::CreateObject; end

# source://representable//lib/representable/deserializer.rb#63
Representable::CreateObject::Class = T.let(T.unsafe(nil), Proc)

# source://representable//lib/representable/deserializer.rb#61
Representable::CreateObject::Instance = T.let(T.unsafe(nil), Proc)

# FIXME: no additional args passed here, yet.
#
# source://representable//lib/representable/deserializer.rb#69
Representable::CreateObject::Populator = T.let(T.unsafe(nil), Proc)

# source://representable//lib/representable/declarative.rb#7
module Representable::Declarative
  include ::Declarative::Schema::DSL
  include ::Declarative::Schema::Feature
  include ::Declarative::Heritage::DSL

  # source://representable//lib/representable/declarative.rb#14
  def collection(name, options = T.unsafe(nil), &block); end

  # source://representable//lib/representable/declarative.rb#47
  def default_nested_class; end

  # source://representable//lib/representable/declarative.rb#66
  def definitions; end

  # source://representable//lib/representable/declarative.rb#18
  def hash(name = T.unsafe(nil), options = T.unsafe(nil), &block); end

  # Allows you to nest a block of properties in a separate section while still mapping
  # them to the original object.
  #
  # source://representable//lib/representable/declarative.rb#27
  def nested(name, options = T.unsafe(nil), &block); end

  # source://representable//lib/representable/declarative.rb#62
  def nested_builder; end

  # source://representable//lib/representable/declarative.rb#66
  def representable_attrs; end

  # source://representable//lib/representable/declarative.rb#8
  def representation_wrap=(name); end
end

# source://representable//lib/representable/declarative.rb#52
Representable::Declarative::NestedBuilder = T.let(T.unsafe(nil), Proc)

# source://representable//lib/representable/deserializer.rb#74
Representable::Decorate = T.let(T.unsafe(nil), Representable::Function::Decorate)

# source://representable//lib/representable/decorator.rb#5
class Representable::Decorator
  include ::Representable
  include ::Representable::Cached
  extend ::Declarative::Schema::DSL
  extend ::Declarative::Schema::Feature
  extend ::Declarative::Heritage::DSL
  extend ::Representable::Declarative
  extend ::Declarative::Heritage::Included
  extend ::Declarative::Heritage::Inherited
  extend ::Representable::ModuleExtensions
  extend ::Representable::ClassMethods
  extend ::Representable::ForCollection
  extend ::Representable::Represent
  extend ::Representable::Cached::BuildDefinition
  extend ::Uber::InheritableAttr

  # @return [Decorator] a new instance of Decorator
  #
  # source://representable//lib/representable/decorator.rb#33
  def initialize(represented); end

  # Returns the value of attribute represented.
  #
  # source://representable//lib/representable/decorator.rb#6
  def decorated; end

  # Returns the value of attribute represented.
  #
  # source://representable//lib/representable/decorator.rb#6
  def represented; end

  class << self
    # This is called from inheritable_attr when inheriting a decorator class to a subclass.
    # Explicitly subclassing the Decorator makes sure representable_attrs is a clean version.
    #
    # source://representable//lib/representable/decorator.rb#22
    def clone; end

    # FIXME. SHOULD we move that into NestedBuilder?
    #
    # source://representable//lib/representable/decorator.rb#14
    def default_nested_class; end

    # source://uber/0.1.0/lib/uber/inheritable_attr.rb#10
    def map; end

    # source://uber/0.1.0/lib/uber/inheritable_attr.rb#6
    def map=(v); end

    # source://representable//lib/representable/decorator.rb#37
    def nested_builder; end

    # TODO: when moving all class methods into ClassMethods, i get a segfault.
    #
    # source://representable//lib/representable/decorator.rb#10
    def prepare(represented); end
  end
end

# source://representable//lib/representable/deserializer.rb#26
Representable::Default = T.let(T.unsafe(nil), Proc)

# Created at class compile time. Keeps configuration options for one property.
#
# source://representable//lib/representable/definition.rb#9
class Representable::Definition < ::Declarative::Definitions::Definition
  # @return [Definition] a new instance of Definition
  #
  # source://representable//lib/representable/definition.rb#11
  def initialize(sym, options = T.unsafe(nil), &block); end

  # source://representable//lib/representable/definition.rb#44
  def [](name); end

  # @return [Boolean]
  #
  # source://representable//lib/representable/definition.rb#64
  def array?; end

  # source://representable//lib/representable/definition.rb#80
  def create_binding(*args); end

  # source://representable//lib/representable/definition.rb#38
  def delete!(name); end

  # source://representable//lib/representable/definition.rb#23
  def getter; end

  # @return [Boolean]
  #
  # source://representable//lib/representable/definition.rb#72
  def has_default?; end

  # @return [Boolean]
  #
  # source://representable//lib/representable/definition.rb#68
  def hash?; end

  # source://representable//lib/representable/definition.rb#84
  def inspect; end

  # source://representable//lib/representable/definition.rb#28
  def merge!(options, &block); end

  # source://representable//lib/representable/definition.rb#23
  def name; end

  # @return [Boolean]
  #
  # source://representable//lib/representable/definition.rb#58
  def representable?; end

  # source://representable//lib/representable/definition.rb#76
  def representer_module; end

  # source://representable//lib/representable/definition.rb#50
  def setter; end

  # TODO: remove.
  #
  # @return [Boolean]
  #
  # source://representable//lib/representable/definition.rb#54
  def typed?; end

  private

  # source://representable//lib/representable/definition.rb#114
  def dynamic_options; end

  # source://representable//lib/representable/definition.rb#122
  def handle_as!(options); end

  # source://representable//lib/representable/definition.rb#118
  def handle_extend!(options); end

  # wrapping dynamic options in Value does save runtime, as this is used very frequently (and totally unnecessary to wrap an option
  # at runtime, its value never changes).
  #
  # source://representable//lib/representable/definition.rb#105
  def runtime_options!(options); end

  # @yield [options]
  #
  # source://representable//lib/representable/definition.rb#90
  def setup!(options, &block); end
end

# source://representable//lib/representable/deserializer.rb#77
Representable::Deserialize = T.let(T.unsafe(nil), Proc)

# source://representable//lib/representable/binding.rb#119
class Representable::DeserializeError < ::RuntimeError; end

# source://representable//lib/representable/deserializer.rb#75
Representable::Deserializer = T.let(T.unsafe(nil), Proc)

# source://representable//lib/representable/populator.rb#34
Representable::FindOrInstantiate = T.let(T.unsafe(nil), Proc)

# Gives us Representer::for_collection and its configuration directive
# ::collection_representer.
#
# source://representable//lib/representable/for_collection.rb#4
module Representable::ForCollection
  # source://representable//lib/representable/for_collection.rb#5
  def for_collection; end

  private

  # source://representable//lib/representable/for_collection.rb#23
  def collection_representer(options = T.unsafe(nil)); end

  # source://representable//lib/representable/for_collection.rb#11
  def collection_representer!(options); end
end

# source://representable//lib/representable/deserializer.rb#34
module Representable::Function; end

# source://representable//lib/representable/deserializer.rb#43
class Representable::Function::Decorate
  # source://representable//lib/representable/deserializer.rb#44
  def call(object, options); end

  # source://representable//lib/representable/deserializer.rb#54
  def prepare_for(mod, object, binding); end
end

# source://representable//lib/representable/deserializer.rb#35
class Representable::Function::Prepare
  # source://representable//lib/representable/deserializer.rb#36
  def call(input, options); end
end

# source://representable//lib/representable/serializer.rb#6
Representable::GetValue = T.let(T.unsafe(nil), Proc)

# source://representable//lib/representable/serializer.rb#2
Representable::Getter = T.let(T.unsafe(nil), Proc)

# The generic representer. Brings #to_hash and #from_hash to your object.
# If you plan to write your own representer for a new media type, try to use this module (e.g., check how JSON reuses Hash's internal
# architecture).
#
# source://representable//lib/representable/hash/binding.rb#4
module Representable::Hash
  include ::Representable

  mixes_in_class_methods ::Representable::Declarative
  mixes_in_class_methods ::Declarative::Heritage::Included
  mixes_in_class_methods ::Declarative::Heritage::Inherited
  mixes_in_class_methods ::Representable::ModuleExtensions
  mixes_in_class_methods ::Representable::ClassMethods
  mixes_in_class_methods ::Representable::ForCollection
  mixes_in_class_methods ::Representable::Represent
  mixes_in_class_methods ::Representable::Hash::ClassMethods

  # source://representable//lib/representable/hash.rb#30
  def from_hash(data, options = T.unsafe(nil), binding_builder = T.unsafe(nil)); end

  # source://representable//lib/representable/hash.rb#30
  def parse(data, options = T.unsafe(nil), binding_builder = T.unsafe(nil)); end

  # source://representable//lib/representable/hash.rb#36
  def render(options = T.unsafe(nil), binding_builder = T.unsafe(nil)); end

  # source://representable//lib/representable/hash.rb#36
  def to_hash(options = T.unsafe(nil), binding_builder = T.unsafe(nil)); end

  private

  # source://representable//lib/representable/hash.rb#49
  def filter_wrap(data, options); end

  # source://representable//lib/representable/hash.rb#56
  def filter_wrap_for(data, wrap); end

  class << self
    # @private
    #
    # source://representable//lib/representable/hash.rb#12
    def included(base); end
  end
end

# source://representable//lib/representable/hash/allow_symbols.rb#5
module Representable::Hash::AllowSymbols
  private

  # source://representable//lib/representable/hash/allow_symbols.rb#8
  def filter_wrap_for(data, *args); end

  # source://representable//lib/representable/hash/allow_symbols.rb#12
  def update_properties_from(data, *args); end
end

# source://representable//lib/representable/hash/binding.rb#5
class Representable::Hash::Binding < ::Representable::Binding
  # source://representable//lib/representable/hash/binding.rb#24
  def deserialize_method; end

  # source://representable//lib/representable/hash/binding.rb#12
  def read(hash, as); end

  # source://representable//lib/representable/hash/binding.rb#20
  def serialize_method; end

  # source://representable//lib/representable/hash/binding.rb#16
  def write(hash, fragment, as); end

  class << self
    # source://representable//lib/representable/hash/binding.rb#6
    def build_for(definition); end
  end
end

# source://representable//lib/representable/hash/binding.rb#28
class Representable::Hash::Binding::Collection < ::Representable::Hash::Binding
  include ::Representable::Binding::Collection
end

# source://representable//lib/representable/hash.rb#20
module Representable::Hash::ClassMethods
  # source://representable//lib/representable/hash.rb#25
  def collection_representer_class; end

  # source://representable//lib/representable/hash.rb#21
  def format_engine; end
end

# source://representable//lib/representable/hash/collection.rb#4
module Representable::Hash::Collection
  include ::Representable::Hash
  include ::Representable
  extend ::Declarative::Schema::DSL
  extend ::Declarative::Schema::Feature
  extend ::Declarative::Heritage::DSL
  extend ::Representable::Declarative
  extend ::Declarative::Heritage::Included
  extend ::Declarative::Heritage::Inherited
  extend ::Representable::ModuleExtensions
  extend ::Representable::ClassMethods
  extend ::Representable::ForCollection
  extend ::Representable::Represent
  extend ::Representable::Hash::ClassMethods
  include ::Representable
  include ::Representable::Hash

  mixes_in_class_methods ::Representable::Declarative
  mixes_in_class_methods ::Declarative::Heritage::Included
  mixes_in_class_methods ::Declarative::Heritage::Inherited
  mixes_in_class_methods ::Representable::ModuleExtensions
  mixes_in_class_methods ::Representable::ClassMethods
  mixes_in_class_methods ::Representable::ForCollection
  mixes_in_class_methods ::Representable::Represent
  mixes_in_class_methods ::Representable::Hash::ClassMethods
  mixes_in_class_methods ::Representable::Hash::Collection::ClassMethods

  # TODO: revise lonely collection and build separate pipeline where we just use Serialize, etc.
  #
  # source://representable//lib/representable/hash/collection.rb#24
  def create_representation_with(doc, options, format); end

  # source://representable//lib/representable/hash/collection.rb#34
  def update_properties_from(doc, options, format); end

  class << self
    # @private
    #
    # source://representable//lib/representable/hash/collection.rb#7
    def included(base); end
  end
end

# source://representable//lib/representable/hash/collection.rb#16
module Representable::Hash::Collection::ClassMethods
  # source://representable//lib/representable/hash/collection.rb#17
  def items(options = T.unsafe(nil), &block); end
end

# source://representable//lib/representable/hash/allow_symbols.rb#17
module Representable::Hash::Conversion
  class << self
    # source://representable//lib/representable/hash/allow_symbols.rb#18
    def stringify_keys(hash); end
  end
end

# source://representable//lib/representable/hash_methods.rb#2
module Representable::HashMethods
  # source://representable//lib/representable/hash_methods.rb#3
  def create_representation_with(doc, options, format); end

  # source://representable//lib/representable/hash_methods.rb#10
  def update_properties_from(doc, options, format); end

  private

  # source://representable//lib/representable/hash_methods.rb#20
  def filter_keys_for!(hash, options); end
end

# source://representable//lib/representable/deserializer.rb#96
Representable::If = T.let(T.unsafe(nil), Proc)

# Brings #to_json and #from_json to your object.
#
# source://representable//lib/representable/json.rb#8
module Representable::JSON
  include ::Representable::Hash
  include ::Representable
  extend ::Representable::Hash::ClassMethods
  extend ::Declarative::Schema::DSL
  extend ::Declarative::Schema::Feature
  extend ::Declarative::Heritage::DSL
  extend ::Representable::Declarative
  extend ::Declarative::Heritage::Included
  extend ::Declarative::Heritage::Inherited
  extend ::Representable::ModuleExtensions
  extend ::Representable::ClassMethods
  extend ::Representable::ForCollection
  extend ::Representable::Represent
  include ::Representable

  mixes_in_class_methods ::Representable::Declarative
  mixes_in_class_methods ::Declarative::Heritage::Included
  mixes_in_class_methods ::Declarative::Heritage::Inherited
  mixes_in_class_methods ::Representable::ModuleExtensions
  mixes_in_class_methods ::Representable::ClassMethods
  mixes_in_class_methods ::Representable::ForCollection
  mixes_in_class_methods ::Representable::Represent
  mixes_in_class_methods ::Representable::JSON::ClassMethods

  # Parses the body as JSON and delegates to #from_hash.
  #
  # source://representable//lib/representable/json.rb#35
  def from_json(data, *args); end

  # Parses the body as JSON and delegates to #from_hash.
  #
  # source://representable//lib/representable/json.rb#35
  def parse(data, *args); end

  # Returns a JSON string representing this object.
  #
  # source://representable//lib/representable/json.rb#41
  def render(*args); end

  # Returns a JSON string representing this object.
  #
  # source://representable//lib/representable/json.rb#41
  def to_json(*args); end

  class << self
    # @private
    #
    # source://representable//lib/representable/json.rb#14
    def included(base); end
  end
end

# source://representable//lib/representable/json.rb#23
module Representable::JSON::ClassMethods
  # source://representable//lib/representable/json.rb#28
  def collection_representer_class; end

  # source://representable//lib/representable/json.rb#24
  def format_engine; end
end

# source://representable//lib/representable/json/collection.rb#5
module Representable::JSON::Collection
  include ::Representable::Hash
  include ::Representable
  include ::Representable::JSON
  extend ::Declarative::Schema::DSL
  extend ::Declarative::Schema::Feature
  extend ::Declarative::Heritage::DSL
  extend ::Representable::Declarative
  extend ::Declarative::Heritage::Included
  extend ::Declarative::Heritage::Inherited
  extend ::Representable::ModuleExtensions
  extend ::Representable::ClassMethods
  extend ::Representable::ForCollection
  extend ::Representable::Represent
  extend ::Representable::JSON::ClassMethods
  include ::Representable
  include ::Representable::Hash
  include ::Representable::Hash::Collection

  mixes_in_class_methods ::Representable::Declarative
  mixes_in_class_methods ::Declarative::Heritage::Included
  mixes_in_class_methods ::Declarative::Heritage::Inherited
  mixes_in_class_methods ::Representable::ModuleExtensions
  mixes_in_class_methods ::Representable::ClassMethods
  mixes_in_class_methods ::Representable::ForCollection
  mixes_in_class_methods ::Representable::Represent
  mixes_in_class_methods ::Representable::Hash::ClassMethods
  mixes_in_class_methods ::Representable::Hash::Collection::ClassMethods

  class << self
    # @private
    #
    # source://representable//lib/representable/json/collection.rb#8
    def included(base); end
  end
end

# "Lonely Hash" support.
#
# source://representable//lib/representable/json/hash.rb#6
module Representable::JSON::Hash
  include ::Representable
  include ::Representable::JSON
  include ::Representable::HashMethods

  mixes_in_class_methods ::Representable::Declarative
  mixes_in_class_methods ::Declarative::Heritage::Included
  mixes_in_class_methods ::Declarative::Heritage::Inherited
  mixes_in_class_methods ::Representable::ModuleExtensions
  mixes_in_class_methods ::Representable::ClassMethods
  mixes_in_class_methods ::Representable::ForCollection
  mixes_in_class_methods ::Representable::Represent
  mixes_in_class_methods ::Representable::JSON::Hash::ClassMethods
  mixes_in_class_methods ::Representable::JSON::ClassMethods

  class << self
    # @private
    #
    # source://representable//lib/representable/json/hash.rb#7
    def included(base); end
  end
end

# source://representable//lib/representable/json/hash.rb#18
module Representable::JSON::Hash::ClassMethods
  # source://representable//lib/representable/json/hash.rb#19
  def values(options, &block); end
end

# source://representable//lib/representable.rb#104
module Representable::ModuleExtensions
  # Copies the representable_attrs reference to the extended object.
  # Note that changing attrs in the instance will affect the class configuration.
  #
  # source://representable//lib/representable.rb#107
  def extended(object); end
end

# source://representable//lib/representable/object/binding.rb#4
module Representable::Object
  include ::Representable

  mixes_in_class_methods ::Representable::Declarative
  mixes_in_class_methods ::Declarative::Heritage::Included
  mixes_in_class_methods ::Declarative::Heritage::Inherited
  mixes_in_class_methods ::Representable::ModuleExtensions
  mixes_in_class_methods ::Representable::ClassMethods
  mixes_in_class_methods ::Representable::ForCollection
  mixes_in_class_methods ::Representable::Represent
  mixes_in_class_methods ::Representable::Object::ClassMethods

  # source://representable//lib/representable/object.rb#21
  def from_object(data, options = T.unsafe(nil), binding_builder = T.unsafe(nil)); end

  # source://representable//lib/representable/object.rb#25
  def to_object(options = T.unsafe(nil), binding_builder = T.unsafe(nil)); end

  class << self
    # @private
    #
    # source://representable//lib/representable/object.rb#6
    def included(base); end
  end
end

# source://representable//lib/representable/object/binding.rb#5
class Representable::Object::Binding < ::Representable::Binding
  # source://representable//lib/representable/object/binding.rb#24
  def deserialize_method; end

  # source://representable//lib/representable/object/binding.rb#12
  def read(hash, as); end

  # source://representable//lib/representable/object/binding.rb#28
  def serialize_method; end

  # source://representable//lib/representable/object/binding.rb#20
  def write(hash, fragment, as); end

  class << self
    # TODO: remove default arg.
    #
    # source://representable//lib/representable/object/binding.rb#6
    def build_for(definition); end
  end
end

# source://representable//lib/representable/object/binding.rb#33
class Representable::Object::Binding::Collection < ::Representable::Object::Binding
  include ::Representable::Binding::Collection
end

# source://representable//lib/representable/object.rb#15
module Representable::Object::ClassMethods
  # source://representable//lib/representable/object.rb#16
  def collection_representer_class; end
end

# Extend `Trailblazer::Option` to support static values as callables too.
#
# source://representable//lib/representable/option.rb#5
class Representable::Option < ::Trailblazer::Option
  class << self
    # source://representable//lib/representable/option.rb#10
    def build(value); end

    # @return [Boolean]
    #
    # source://representable//lib/representable/option.rb#6
    def callable?(value); end
  end
end

# Prepares options for a particular nested representer.
# This is used in Serializer and Deserializer.
#
# source://representable//lib/representable.rb#81
Representable::OptionsForNested = T.let(T.unsafe(nil), Proc)

# source://representable//lib/representable/deserializer.rb#22
Representable::OverwriteOnNil = T.let(T.unsafe(nil), Proc)

# source://representable//lib/representable/deserializer.rb#86
Representable::ParseFilter = T.let(T.unsafe(nil), Proc)

# Allows to implement a pipeline of filters where a value gets passed in and the result gets
# passed to the next callable object.
#
# source://representable//lib/representable/pipeline.rb#4
class Representable::Pipeline < ::Array
  extend ::Representable::Pipeline::Macros

  # options is mutable.
  #
  # source://representable//lib/representable/pipeline.rb#8
  def call(input, options); end

  private

  # source://representable//lib/representable/pipeline.rb#18
  def evaluate(block, input, options); end
end

# source://representable//lib/representable/insert.rb#3
module Representable::Pipeline::Function; end

# source://representable//lib/representable/insert.rb#4
class Representable::Pipeline::Function::Insert
  # source://representable//lib/representable/insert.rb#5
  def call(arr, func, options); end

  private

  # source://representable//lib/representable/insert.rb#23
  def delete!(arr, removed_func); end

  # source://representable//lib/representable/insert.rb#13
  def replace!(arr, old_func, new_func); end
end

# source://representable//lib/representable/insert.rb#36
Representable::Pipeline::Insert = T.let(T.unsafe(nil), Representable::Pipeline::Function::Insert)

# TODO: explicit test.
#
# source://representable//lib/representable/pipeline.rb#23
module Representable::Pipeline::Macros
  # Macro to quickly modify an array of functions via Pipeline::Insert and return a
  # Pipeline instance.
  #
  # source://representable//lib/representable/pipeline.rb#26
  def insert(functions, new_function, options); end
end

# source://representable//lib/representable/pipeline.rb#5
class Representable::Pipeline::Stop; end

# source://representable//lib/representable/populator.rb#2
class Representable::Populator
  class << self
    # pipeline: [StopOnExcluded, AssignName, ReadFragment, StopOnNotFound, OverwriteOnNil, AssignFragment, #<Representable::Function::CreateObject:0x9805a44>, #<Representable::Function::Decorate:0x9805a1c>, Deserialize, Set]
    #
    # source://representable//lib/representable/populator.rb#21
    def apply!(options); end
  end
end

# source://representable//lib/representable/populator.rb#3
Representable::Populator::FindOrInstantiate = T.let(T.unsafe(nil), Proc)

# CreateObject = Function::CreateObject.new
#
# source://representable//lib/representable/deserializer.rb#73
Representable::Prepare = T.let(T.unsafe(nil), Representable::Function::Prepare)

# source://representable//lib/representable/deserializer.rb#11
Representable::ReadFragment = T.let(T.unsafe(nil), Proc)

# source://representable//lib/representable/deserializer.rb#12
Representable::Reader = T.let(T.unsafe(nil), Proc)

# TODO: evaluate this, if we need this.
#
# source://representable//lib/representable/serializer.rb#14
Representable::RenderDefault = T.let(T.unsafe(nil), Proc)

# source://representable//lib/representable/serializer.rb#24
Representable::RenderFilter = T.let(T.unsafe(nil), Proc)

# source://representable//lib/representable/represent.rb#1
module Representable::Represent
  # source://representable//lib/representable/represent.rb#2
  def represent(represented, array_class = T.unsafe(nil)); end
end

# source://representable//lib/representable/serializer.rb#38
Representable::Serialize = T.let(T.unsafe(nil), Proc)

# source://representable//lib/representable/serializer.rb#32
Representable::Serializer = T.let(T.unsafe(nil), Proc)

# source://representable//lib/representable/deserializer.rb#91
Representable::SetValue = T.let(T.unsafe(nil), Proc)

# source://representable//lib/representable/deserializer.rb#90
Representable::Setter = T.let(T.unsafe(nil), Proc)

# source://representable//lib/representable/deserializer.rb#30
Representable::SkipParse = T.let(T.unsafe(nil), Proc)

# source://representable//lib/representable/serializer.rb#28
Representable::SkipRender = T.let(T.unsafe(nil), Proc)

# source://representable//lib/representable/deserializer.rb#94
Representable::Stop = T.let(T.unsafe(nil), Proc)

# source://representable//lib/representable/deserializer.rb#98
Representable::StopOnExcluded = T.let(T.unsafe(nil), Proc)

# DISCUSS: Not tested/used, yet.
#
# source://representable//lib/representable/deserializer.rb#18
Representable::StopOnNil = T.let(T.unsafe(nil), Proc)

# source://representable//lib/representable/deserializer.rb#14
Representable::StopOnNotFound = T.let(T.unsafe(nil), Proc)

# source://representable//lib/representable/serializer.rb#20
Representable::StopOnSkipable = T.let(T.unsafe(nil), Proc)

# source://representable//lib/representable/serializer.rb#48
Representable::WriteFragment = T.let(T.unsafe(nil), Proc)

# source://representable//lib/representable/serializer.rb#8
Representable::Writer = T.let(T.unsafe(nil), Proc)

# source://representable//lib/representable/xml.rb#7
module Representable::XML
  include ::Representable

  mixes_in_class_methods ::Representable::Declarative
  mixes_in_class_methods ::Declarative::Heritage::Included
  mixes_in_class_methods ::Declarative::Heritage::Inherited
  mixes_in_class_methods ::Representable::ModuleExtensions
  mixes_in_class_methods ::Representable::ClassMethods
  mixes_in_class_methods ::Representable::ForCollection
  mixes_in_class_methods ::Representable::Represent
  mixes_in_class_methods ::Representable::XML::ClassMethods

  # source://representable//lib/representable/xml.rb#42
  def from_node(node, options = T.unsafe(nil)); end

  # source://representable//lib/representable/xml.rb#36
  def from_xml(doc, *args); end

  # source://representable//lib/representable/xml.rb#36
  def parse(doc, *args); end

  # source://representable//lib/representable/xml.rb#54
  def render(*args); end

  # Returns a Nokogiri::XML object representing this object.
  #
  # source://representable//lib/representable/xml.rb#47
  def to_node(options = T.unsafe(nil)); end

  # source://representable//lib/representable/xml.rb#54
  def to_xml(*args); end

  private

  # source://representable//lib/representable/xml/binding.rb#5
  def Node(document, name, attributes = T.unsafe(nil)); end

  # source://representable//lib/representable/xml.rb#67
  def parse_xml(doc, *args); end

  # @return [Boolean]
  #
  # source://representable//lib/representable/xml.rb#62
  def remove_namespaces?; end

  class << self
    # source://representable//lib/representable/xml/binding.rb#5
    def Node(document, name, attributes = T.unsafe(nil)); end

    # @private
    #
    # source://representable//lib/representable/xml.rb#12
    def included(base); end
  end
end

# source://representable//lib/representable/xml/binding.rb#12
class Representable::XML::Binding < ::Representable::Binding
  # source://representable//lib/representable/xml/binding.rb#56
  def deserialize_from(nodes); end

  # source://representable//lib/representable/xml/binding.rb#65
  def deserialize_method; end

  # source://representable//lib/representable/xml/binding.rb#33
  def read(node, as); end

  # Creates wrapped node for the property.
  #
  # source://representable//lib/representable/xml/binding.rb#41
  def serialize_for(value, parent, as); end

  # DISCUSS: why is this public?
  #
  # source://representable//lib/representable/xml/binding.rb#61
  def serialize_method; end

  # source://representable//lib/representable/xml/binding.rb#46
  def serialize_node(node, value, as); end

  # source://representable//lib/representable/xml/binding.rb#23
  def write(parent, fragments, as); end

  private

  # TODO: move this into a ScalarDecorator.
  #
  # source://representable//lib/representable/xml/binding.rb#76
  def content_for(node); end

  # source://representable//lib/representable/xml/binding.rb#70
  def find_nodes(doc, as); end

  class << self
    # source://representable//lib/representable/xml/binding.rb#13
    def build_for(definition); end
  end
end

# Represents a tag attribute. Currently this only works on the top-level tag.
#
# source://representable//lib/representable/xml/binding.rb#141
class Representable::XML::Binding::Attribute < ::Representable::XML::Binding
  # source://representable//lib/representable/xml/binding.rb#142
  def read(node, as); end

  # source://representable//lib/representable/xml/binding.rb#146
  def serialize_for(value, parent, as); end

  # source://representable//lib/representable/xml/binding.rb#150
  def write(parent, value, as); end
end

# source://representable//lib/representable/xml/binding.rb#124
class Representable::XML::Binding::AttributeHash < ::Representable::XML::Binding::Collection
  # FIXME: this is not tested!
  #
  # source://representable//lib/representable/xml/binding.rb#134
  def deserialize_from(node); end

  # DISCUSS: use AttributeBinding here?
  #
  # source://representable//lib/representable/xml/binding.rb#126
  def write(parent, value, as); end
end

# source://representable//lib/representable/xml/binding.rb#83
class Representable::XML::Binding::Collection < ::Representable::XML::Binding
  include ::Representable::Binding::Collection

  # source://representable//lib/representable/xml/binding.rb#91
  def deserialize_from(nodes); end

  # source://representable//lib/representable/xml/binding.rb#86
  def serialize_for(value, parent, as); end

  private

  # source://representable//lib/representable/xml/binding.rb#100
  def set_for(parent, nodes); end
end

# Represents tag content.
#
# source://representable//lib/representable/xml/binding.rb#156
class Representable::XML::Binding::Content < ::Representable::XML::Binding
  # source://representable//lib/representable/xml/binding.rb#157
  def read(node, as); end

  # source://representable//lib/representable/xml/binding.rb#161
  def serialize_for(value, parent); end

  # source://representable//lib/representable/xml/binding.rb#165
  def write(parent, value, as); end
end

# source://representable//lib/representable/xml/binding.rb#106
class Representable::XML::Binding::Hash < ::Representable::XML::Binding::Collection
  # source://representable//lib/representable/xml/binding.rb#114
  def deserialize_from(nodes); end

  # source://representable//lib/representable/xml/binding.rb#107
  def serialize_for(value, parent, as); end
end

# source://representable//lib/representable/xml.rb#22
module Representable::XML::ClassMethods
  # source://representable//lib/representable/xml.rb#31
  def collection_representer_class; end

  # source://representable//lib/representable/xml.rb#27
  def format_engine; end

  # source://representable//lib/representable/xml.rb#23
  def remove_namespaces!; end
end

# source://representable//lib/representable/xml/collection.rb#2
module Representable::XML::Collection
  include ::Representable
  include ::Representable::XML
  include ::Representable::Hash
  include ::Representable::Hash::Collection
  include ::Representable::XML::Collection::Methods

  mixes_in_class_methods ::Representable::Declarative
  mixes_in_class_methods ::Declarative::Heritage::Included
  mixes_in_class_methods ::Declarative::Heritage::Inherited
  mixes_in_class_methods ::Representable::ModuleExtensions
  mixes_in_class_methods ::Representable::ClassMethods
  mixes_in_class_methods ::Representable::ForCollection
  mixes_in_class_methods ::Representable::Represent
  mixes_in_class_methods ::Representable::XML::ClassMethods
  mixes_in_class_methods ::Representable::Hash::ClassMethods
  mixes_in_class_methods ::Representable::Hash::Collection::ClassMethods

  class << self
    # @private
    #
    # source://representable//lib/representable/xml/collection.rb#3
    def included(base); end
  end
end

# source://representable//lib/representable/xml/collection.rb#9
module Representable::XML::Collection::Methods
  # source://representable//lib/representable/xml/collection.rb#10
  def create_representation_with(doc, options, format); end

  # source://representable//lib/representable/xml/collection.rb#15
  def update_properties_from(doc, *args); end
end

# Experimental!
# Best explanation so far: http://books.xmlschemata.org/relaxng/relax-CHP-11-SECT-1.html
#
# Note: This module doesn't work with JRuby because Nokogiri uses a completely
# different implementation in Java which has other requirements that we couldn't fulfil.
# Please wait for Representable 4 where we replace Nokogiri with Oga.
#
# source://representable//lib/representable/xml/namespace.rb#8
module Representable::XML::Namespace
  mixes_in_class_methods ::Representable::XML::Namespace::DSL

  # "Physically" add `xmlns` attributes to `node`.
  #
  # source://representable//lib/representable/xml/namespace.rb#104
  def add_namespace_definitions!(node, namespaces); end

  # FIXME: some "bug" in Representable's XML doesn't consider the container tag, so we could theoretically pick the
  # wrong namespaced tag here :O
  #
  # source://representable//lib/representable/xml/namespace.rb#81
  def from_node(node, options = T.unsafe(nil)); end

  # FIXME: this is a PoC, we need a better API to inject code.
  #
  # source://representable//lib/representable/xml/namespace.rb#116
  def representable_map(options, format); end

  # source://representable//lib/representable/xml/namespace.rb#85
  def to_node(options = T.unsafe(nil)); end

  class << self
    # source://representable//lib/representable/xml/namespace.rb#111
    def Namespaced(prefix, name); end

    # @private
    #
    # source://representable//lib/representable/xml/namespace.rb#9
    def included(includer); end
  end
end

# source://representable//lib/representable/xml/namespace.rb#61
module Representable::XML::Namespace::AsWithNamespace
  # FIXME: this is shit, the NestedOptions is executed too late here!
  #
  # source://representable//lib/representable/xml/namespace.rb#67
  def read(node, as); end

  # source://representable//lib/representable/xml/namespace.rb#62
  def write(doc, fragment, as); end

  private

  # source://representable//lib/representable/xml/namespace.rb#72
  def prefixed(dfn, as); end
end

# source://representable//lib/representable/xml/namespace.rb#13
module Representable::XML::Namespace::DSL
  # source://representable//lib/representable/xml/namespace.rb#14
  def namespace(namespace); end

  # source://representable//lib/representable/xml/namespace.rb#20
  def namespace_def(mapping); end

  # :private:
  #
  # source://representable//lib/representable/xml/namespace.rb#25
  def namespace_defs; end

  # source://representable//lib/representable/xml/namespace.rb#29
  def property(name, options = T.unsafe(nil)); end

  # :private:
  # super ugly hack
  # recursively injects the namespace_defs into all representers of this tree. will be done better in 4.0.
  #
  # source://representable//lib/representable/xml/namespace.rb#48
  def update_namespace_defs!(namespace_defs); end
end

# source://representable//lib/representable/yaml.rb#5
module Representable::YAML
  include ::Representable::Hash
  include ::Representable
  extend ::Declarative::Schema::DSL
  extend ::Declarative::Schema::Feature
  extend ::Declarative::Heritage::DSL
  extend ::Representable::Declarative
  extend ::Declarative::Heritage::Included
  extend ::Declarative::Heritage::Inherited
  extend ::Representable::ModuleExtensions
  extend ::Representable::ClassMethods
  extend ::Representable::ForCollection
  extend ::Representable::Represent
  extend ::Representable::Hash::ClassMethods
  include ::Representable

  mixes_in_class_methods ::Representable::Declarative
  mixes_in_class_methods ::Declarative::Heritage::Included
  mixes_in_class_methods ::Declarative::Heritage::Inherited
  mixes_in_class_methods ::Representable::ModuleExtensions
  mixes_in_class_methods ::Representable::ClassMethods
  mixes_in_class_methods ::Representable::ForCollection
  mixes_in_class_methods ::Representable::Represent
  mixes_in_class_methods ::Representable::YAML::ClassMethods

  # source://representable//lib/representable/yaml.rb#23
  def from_yaml(doc, options = T.unsafe(nil)); end

  # source://representable//lib/representable/yaml.rb#23
  def parse(doc, options = T.unsafe(nil)); end

  # source://representable//lib/representable/yaml.rb#35
  def render(*args); end

  # Returns a Nokogiri::XML object representing this object.
  #
  # source://representable//lib/representable/yaml.rb#29
  def to_ast(options = T.unsafe(nil)); end

  # source://representable//lib/representable/yaml.rb#35
  def to_yaml(*args); end

  class << self
    # @private
    #
    # source://representable//lib/representable/yaml.rb#9
    def included(base); end
  end
end

# source://representable//lib/representable/yaml/binding.rb#5
class Representable::YAML::Binding < ::Representable::Hash::Binding
  # source://representable//lib/representable/yaml/binding.rb#32
  def deserialize_method; end

  # private
  #
  # source://representable//lib/representable/yaml/binding.rb#18
  def node_for(fragment); end

  # source://representable//lib/representable/yaml/binding.rb#28
  def serialize_method; end

  # source://representable//lib/representable/yaml/binding.rb#12
  def write(map, fragment, as); end

  # source://representable//lib/representable/yaml/binding.rb#22
  def write_scalar(value); end

  class << self
    # source://representable//lib/representable/yaml/binding.rb#6
    def build_for(definition); end
  end
end

# source://representable//lib/representable/yaml/binding.rb#37
class Representable::YAML::Binding::Collection < ::Representable::YAML::Binding
  include ::Representable::Binding::Collection

  # source://representable//lib/representable/yaml/binding.rb#40
  def node_for(fragments); end
end

# source://representable//lib/representable/yaml.rb#17
module Representable::YAML::ClassMethods
  # source://representable//lib/representable/yaml.rb#18
  def format_engine; end
end
