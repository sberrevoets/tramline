# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `june-analytics-ruby` gem.
# Please instead update this file by running `bin/tapioca gem june-analytics-ruby`.


# source://june-analytics-ruby//lib/june/analytics/version.rb#1
module June; end

# source://june-analytics-ruby//lib/june/analytics/version.rb#2
class June::Analytics
  include ::June::Analytics::Logging

  # Initializes a new instance of {June::Analytics::Client}, to which all
  # method calls are proxied.
  #
  # @option options
  # @param options includes options that are passed down to
  #   {June::Analytics::Client#initialize}
  # @return [Analytics] a new instance of Analytics
  #
  # source://june-analytics-ruby//lib/june/analytics.rb#21
  def initialize(options = T.unsafe(nil)); end

  # source://june-analytics-ruby//lib/june/analytics.rb#26
  def method_missing(message, *args, &block); end

  private

  # @return [Boolean]
  #
  # source://june-analytics-ruby//lib/june/analytics.rb#34
  def respond_to_missing?(method_name, include_private = T.unsafe(nil)); end

  class << self
    # source://june-analytics-ruby//lib/june/analytics/logging.rb#49
    def logger; end
  end
end

# source://june-analytics-ruby//lib/june/analytics/backoff_policy.rb#5
class June::Analytics::BackoffPolicy
  include ::June::Analytics::Defaults::BackoffPolicy

  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param opts [Hash]
  # @return [BackoffPolicy] a new instance of BackoffPolicy
  #
  # source://june-analytics-ruby//lib/june/analytics/backoff_policy.rb#15
  def initialize(opts = T.unsafe(nil)); end

  # @return [Numeric] the next backoff interval, in milliseconds.
  #
  # source://june-analytics-ruby//lib/june/analytics/backoff_policy.rb#25
  def next_interval; end

  private

  # source://june-analytics-ruby//lib/june/analytics/backoff_policy.rb#36
  def add_jitter(base, randomization_factor); end
end

# source://june-analytics-ruby//lib/june/analytics/client.rb#11
class June::Analytics::Client
  include ::June::Analytics::Utils
  include ::June::Analytics::Logging

  # @option opts
  # @option opts
  # @option opts
  # @param opts [Hash]
  # @return [Client] a new instance of Client
  #
  # source://june-analytics-ruby//lib/june/analytics/client.rb#20
  def initialize(opts = T.unsafe(nil)); end

  # Aliases a user from one id to another
  #
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @param attrs [Hash]
  # @see https://segment.com/docs/sources/server/ruby/#alias
  #
  # source://june-analytics-ruby//lib/june/analytics/client.rb#96
  def alias(attrs); end

  # Synchronously waits until the worker has flushed the queue.
  #
  # Use only for scripts which are not long-running, and will specifically
  # exit
  #
  # source://june-analytics-ruby//lib/june/analytics/client.rb#40
  def flush; end

  # Associates a user identity with a group.
  #
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @param attrs [Hash]
  # @see https://segment.com/docs/sources/server/ruby/#group
  #
  # source://june-analytics-ruby//lib/june/analytics/client.rb#110
  def group(attrs); end

  # Identifies a user
  #
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @param attrs [Hash]
  # @see https://segment.com/docs/sources/server/ruby/#identify
  #
  # source://june-analytics-ruby//lib/june/analytics/client.rb#83
  def identify(attrs); end

  # Records a page view
  #
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @param attrs [Hash]
  # @see https://segment.com/docs/sources/server/ruby/#page
  #
  # source://june-analytics-ruby//lib/june/analytics/client.rb#124
  def page(attrs); end

  # @return [Fixnum] number of messages in the queue
  #
  # source://june-analytics-ruby//lib/june/analytics/client.rb#143
  def queued_messages; end

  # Records a screen view (for a mobile app)
  #
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @param attrs [Hash]
  #
  # source://june-analytics-ruby//lib/june/analytics/client.rb#137
  def screen(attrs); end

  # source://june-analytics-ruby//lib/june/analytics/client.rb#147
  def test_queue; end

  # Tracks an event
  #
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @param attrs [Hash]
  # @see https://segment.com/docs/sources/server/ruby/#track
  #
  # source://june-analytics-ruby//lib/june/analytics/client.rb#70
  def track(attrs); end

  private

  # private: Checks that the write_key is properly initialized
  #
  # @raise [ArgumentError]
  #
  # source://june-analytics-ruby//lib/june/analytics/client.rb#183
  def check_write_key!; end

  # private: Enqueues the action.
  #
  # returns Boolean of whether the item was added to the queue.
  #
  # source://june-analytics-ruby//lib/june/analytics/client.rb#160
  def enqueue(action); end

  # source://june-analytics-ruby//lib/june/analytics/client.rb#187
  def ensure_worker_running; end

  # @return [Boolean]
  #
  # source://june-analytics-ruby//lib/june/analytics/client.rb#197
  def worker_running?; end

  class << self
    # source://june-analytics-ruby//lib/june/analytics/logging.rb#49
    def logger; end
  end
end

# source://june-analytics-ruby//lib/june/analytics/defaults.rb#3
module June::Analytics::Defaults; end

# source://june-analytics-ruby//lib/june/analytics/defaults.rb#28
module June::Analytics::Defaults::BackoffPolicy; end

# source://june-analytics-ruby//lib/june/analytics/defaults.rb#30
June::Analytics::Defaults::BackoffPolicy::MAX_TIMEOUT_MS = T.let(T.unsafe(nil), Integer)

# source://june-analytics-ruby//lib/june/analytics/defaults.rb#29
June::Analytics::Defaults::BackoffPolicy::MIN_TIMEOUT_MS = T.let(T.unsafe(nil), Integer)

# source://june-analytics-ruby//lib/june/analytics/defaults.rb#31
June::Analytics::Defaults::BackoffPolicy::MULTIPLIER = T.let(T.unsafe(nil), Float)

# source://june-analytics-ruby//lib/june/analytics/defaults.rb#32
June::Analytics::Defaults::BackoffPolicy::RANDOMIZATION_FACTOR = T.let(T.unsafe(nil), Float)

# source://june-analytics-ruby//lib/june/analytics/defaults.rb#19
module June::Analytics::Defaults::Message; end

# 32Kb
#
# source://june-analytics-ruby//lib/june/analytics/defaults.rb#20
June::Analytics::Defaults::Message::MAX_BYTES = T.let(T.unsafe(nil), Integer)

# source://june-analytics-ruby//lib/june/analytics/defaults.rb#23
module June::Analytics::Defaults::MessageBatch; end

# 500Kb
#
# source://june-analytics-ruby//lib/june/analytics/defaults.rb#24
June::Analytics::Defaults::MessageBatch::MAX_BYTES = T.let(T.unsafe(nil), Integer)

# source://june-analytics-ruby//lib/june/analytics/defaults.rb#25
June::Analytics::Defaults::MessageBatch::MAX_SIZE = T.let(T.unsafe(nil), Integer)

# source://june-analytics-ruby//lib/june/analytics/defaults.rb#15
module June::Analytics::Defaults::Queue; end

# source://june-analytics-ruby//lib/june/analytics/defaults.rb#16
June::Analytics::Defaults::Queue::MAX_SIZE = T.let(T.unsafe(nil), Integer)

# source://june-analytics-ruby//lib/june/analytics/defaults.rb#4
module June::Analytics::Defaults::Request; end

# source://june-analytics-ruby//lib/june/analytics/defaults.rb#9
June::Analytics::Defaults::Request::HEADERS = T.let(T.unsafe(nil), Hash)

# source://june-analytics-ruby//lib/june/analytics/defaults.rb#5
June::Analytics::Defaults::Request::HOST = T.let(T.unsafe(nil), String)

# source://june-analytics-ruby//lib/june/analytics/defaults.rb#7
June::Analytics::Defaults::Request::PATH = T.let(T.unsafe(nil), String)

# source://june-analytics-ruby//lib/june/analytics/defaults.rb#6
June::Analytics::Defaults::Request::PORT = T.let(T.unsafe(nil), Integer)

# source://june-analytics-ruby//lib/june/analytics/defaults.rb#12
June::Analytics::Defaults::Request::RETRIES = T.let(T.unsafe(nil), Integer)

# source://june-analytics-ruby//lib/june/analytics/defaults.rb#8
June::Analytics::Defaults::Request::SSL = T.let(T.unsafe(nil), TrueClass)

# Handles parsing fields according to the June Spec
#
# @see https://june.so/docs/ruby
#
# source://june-analytics-ruby//lib/june/analytics/field_parser.rb#6
class June::Analytics::FieldParser
  extend ::June::Analytics::Utils

  class << self
    # In addition to the common fields, alias accepts:
    #
    # - "previous_id"
    #
    # source://june-analytics-ruby//lib/june/analytics/field_parser.rb#51
    def parse_for_alias(fields); end

    # In addition to the common fields, group accepts:
    #
    # - "group_id"
    # - "traits"
    #
    # source://june-analytics-ruby//lib/june/analytics/field_parser.rb#67
    def parse_for_group(fields); end

    # In addition to the common fields, identify accepts:
    #
    # - "traits"
    #
    # source://june-analytics-ruby//lib/june/analytics/field_parser.rb#35
    def parse_for_identify(fields); end

    # In addition to the common fields, page accepts:
    #
    # - "name"
    # - "properties"
    #
    # source://june-analytics-ruby//lib/june/analytics/field_parser.rb#89
    def parse_for_page(fields); end

    # In addition to the common fields, screen accepts:
    #
    # - "name"
    # - "properties"
    # - "category" (Not in spec, retained for backward compatibility"
    #
    # source://june-analytics-ruby//lib/june/analytics/field_parser.rb#111
    def parse_for_screen(fields); end

    # In addition to the common fields, track accepts:
    #
    # - "event"
    # - "properties"
    #
    # source://june-analytics-ruby//lib/june/analytics/field_parser.rb#14
    def parse_for_track(fields); end

    private

    # source://june-analytics-ruby//lib/june/analytics/field_parser.rb#173
    def add_context!(context); end

    # @return [Boolean]
    #
    # source://june-analytics-ruby//lib/june/analytics/field_parser.rb#185
    def blank?(obj); end

    # @raise [ArgumentError]
    #
    # source://june-analytics-ruby//lib/june/analytics/field_parser.rb#189
    def check_is_hash!(obj, name); end

    # private: Ensures that a string is non-empty
    #
    # obj    - String|Number that must be non-blank
    # name   - Name of the validated value
    #
    # @raise [ArgumentError]
    #
    # source://june-analytics-ruby//lib/june/analytics/field_parser.rb#181
    def check_presence!(obj, name); end

    # @raise [ArgumentError]
    #
    # source://june-analytics-ruby//lib/june/analytics/field_parser.rb#169
    def check_timestamp!(timestamp); end

    # @raise [ArgumentError]
    #
    # source://june-analytics-ruby//lib/june/analytics/field_parser.rb#162
    def check_user_id!(fields); end

    # source://june-analytics-ruby//lib/june/analytics/field_parser.rb#136
    def parse_common_fields(fields); end
  end
end

# source://june-analytics-ruby//lib/june/analytics/logging.rb#29
module June::Analytics::Logging
  # source://june-analytics-ruby//lib/june/analytics/logging.rb#55
  def logger; end

  class << self
    # @private
    #
    # source://june-analytics-ruby//lib/june/analytics/logging.rb#47
    def included(base); end

    # source://june-analytics-ruby//lib/june/analytics/logging.rb#31
    def logger; end

    # Sets the attribute logger
    #
    # @param value the value to set the attribute logger to.
    #
    # source://june-analytics-ruby//lib/june/analytics/logging.rb#44
    def logger=(_arg0); end
  end
end

# A batch of `Message`s to be sent to the API
#
# source://june-analytics-ruby//lib/june/analytics/message_batch.rb#7
class June::Analytics::MessageBatch
  include ::June::Analytics::Logging
  include ::June::Analytics::Defaults::MessageBatch
  extend ::Forwardable

  # @return [MessageBatch] a new instance of MessageBatch
  #
  # source://june-analytics-ruby//lib/june/analytics/message_batch.rb#14
  def initialize(max_message_count); end

  # source://june-analytics-ruby//lib/june/analytics/message_batch.rb#20
  def <<(message); end

  # source://june-analytics-ruby//lib/june/analytics/message_batch.rb#40
  def clear; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def empty?(*args, **_arg1, &block); end

  # @return [Boolean]
  #
  # source://june-analytics-ruby//lib/june/analytics/message_batch.rb#36
  def full?; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def length(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_json(*args, **_arg1, &block); end

  private

  # @return [Boolean]
  #
  # source://june-analytics-ruby//lib/june/analytics/message_batch.rb#51
  def item_count_exhausted?; end

  # @return [Boolean]
  #
  # source://june-analytics-ruby//lib/june/analytics/message_batch.rb#55
  def message_too_big?(message_json_size); end

  # We consider the max size here as just enough to leave room for one more
  # message of the largest size possible. This is a shortcut that allows us
  # to use a native Ruby `Queue` that doesn't allow peeking. The tradeoff
  # here is that we might fit in less messages than possible into a batch.
  #
  # The alternative is to use our own `Queue` implementation that allows
  # peeking, and to consider the next message size when calculating whether
  # the message can be accomodated in this batch.
  #
  # @return [Boolean]
  #
  # source://june-analytics-ruby//lib/june/analytics/message_batch.rb#67
  def size_exhausted?; end

  class << self
    # source://june-analytics-ruby//lib/june/analytics/logging.rb#49
    def logger; end
  end
end

# source://june-analytics-ruby//lib/june/analytics/message_batch.rb#8
class June::Analytics::MessageBatch::JSONGenerationError < ::StandardError; end

# Wraps an existing logger and adds a prefix to all messages
#
# source://june-analytics-ruby//lib/june/analytics/logging.rb#6
class June::Analytics::PrefixedLogger
  # @return [PrefixedLogger] a new instance of PrefixedLogger
  #
  # source://june-analytics-ruby//lib/june/analytics/logging.rb#7
  def initialize(logger, prefix); end

  # source://june-analytics-ruby//lib/june/analytics/logging.rb#12
  def debug(msg); end

  # source://june-analytics-ruby//lib/june/analytics/logging.rb#24
  def error(msg); end

  # source://june-analytics-ruby//lib/june/analytics/logging.rb#16
  def info(msg); end

  # source://june-analytics-ruby//lib/june/analytics/logging.rb#20
  def warn(msg); end
end

# source://june-analytics-ruby//lib/june/analytics/response.rb#3
class June::Analytics::Response
  # public: Simple class to wrap responses from the API
  #
  # @return [Response] a new instance of Response
  #
  # source://june-analytics-ruby//lib/june/analytics/response.rb#9
  def initialize(status = T.unsafe(nil), error = T.unsafe(nil)); end

  # Returns the value of attribute error.
  #
  # source://june-analytics-ruby//lib/june/analytics/response.rb#4
  def error; end

  # Returns the value of attribute status.
  #
  # source://june-analytics-ruby//lib/june/analytics/response.rb#4
  def status; end
end

# source://june-analytics-ruby//lib/june/analytics/test_queue.rb#3
class June::Analytics::TestQueue
  # @return [TestQueue] a new instance of TestQueue
  #
  # source://june-analytics-ruby//lib/june/analytics/test_queue.rb#6
  def initialize; end

  # source://june-analytics-ruby//lib/june/analytics/test_queue.rb#18
  def <<(message); end

  # source://june-analytics-ruby//lib/june/analytics/test_queue.rb#10
  def [](key); end

  # source://june-analytics-ruby//lib/june/analytics/test_queue.rb#23
  def alias; end

  # source://june-analytics-ruby//lib/june/analytics/test_queue.rb#27
  def all; end

  # source://june-analytics-ruby//lib/june/analytics/test_queue.rb#14
  def count; end

  # source://june-analytics-ruby//lib/june/analytics/test_queue.rb#31
  def group; end

  # source://june-analytics-ruby//lib/june/analytics/test_queue.rb#35
  def identify; end

  # Returns the value of attribute messages.
  #
  # source://june-analytics-ruby//lib/june/analytics/test_queue.rb#4
  def messages; end

  # source://june-analytics-ruby//lib/june/analytics/test_queue.rb#39
  def page; end

  # source://june-analytics-ruby//lib/june/analytics/test_queue.rb#51
  def reset!; end

  # source://june-analytics-ruby//lib/june/analytics/test_queue.rb#43
  def screen; end

  # source://june-analytics-ruby//lib/june/analytics/test_queue.rb#47
  def track; end
end

# source://june-analytics-ruby//lib/june/analytics/transport.rb#12
class June::Analytics::Transport
  include ::June::Analytics::Defaults::Request
  include ::June::Analytics::Utils
  include ::June::Analytics::Logging

  # @return [Transport] a new instance of Transport
  #
  # source://june-analytics-ruby//lib/june/analytics/transport.rb#17
  def initialize(options = T.unsafe(nil)); end

  # Sends a batch of messages to the API
  #
  # @return [Response] API response
  #
  # source://june-analytics-ruby//lib/june/analytics/transport.rb#38
  def send(write_key, batch); end

  # Closes a persistent connection if it exists
  #
  # source://june-analytics-ruby//lib/june/analytics/transport.rb#61
  def shutdown; end

  private

  # Takes a block that returns [result, should_retry].
  #
  # Retries upto `retries_remaining` times, if `should_retry` is false or
  # an exception is raised. `@backoff_policy` is used to determine the
  # duration to sleep between attempts
  #
  # Returns [last_result, raised_exception]
  #
  # source://june-analytics-ruby//lib/june/analytics/transport.rb#87
  def retry_with_backoff(retries_remaining, &block); end

  # Sends a request for the batch, returns [status_code, body]
  #
  # source://june-analytics-ruby//lib/june/analytics/transport.rb#109
  def send_request(write_key, batch); end

  # @return [Boolean]
  #
  # source://june-analytics-ruby//lib/june/analytics/transport.rb#67
  def should_retry_request?(status_code, body); end

  class << self
    # source://june-analytics-ruby//lib/june/analytics/logging.rb#49
    def logger; end

    # source://june-analytics-ruby//lib/june/analytics/transport.rb#132
    def stub; end

    # Sets the attribute stub
    #
    # @param value the value to set the attribute stub to.
    #
    # source://june-analytics-ruby//lib/june/analytics/transport.rb#130
    def stub=(_arg0); end
  end
end

# source://june-analytics-ruby//lib/june/analytics/utils.rb#5
module June::Analytics::Utils
  extend ::June::Analytics::Utils

  # source://june-analytics-ruby//lib/june/analytics/utils.rb#71
  def date_in_iso8601(date); end

  # source://june-analytics-ruby//lib/june/analytics/utils.rb#54
  def datetime_in_iso8601(datetime); end

  # source://june-analytics-ruby//lib/june/analytics/utils.rb#75
  def formatted_offset(time, colon = T.unsafe(nil), alternate_utc_string = T.unsafe(nil)); end

  # public: Returns a new hash with all the date values in the into iso8601
  #         strings
  #
  # source://june-analytics-ruby//lib/june/analytics/utils.rb#33
  def isoify_dates(hash); end

  # public: Converts all the date values in the into iso8601 strings in place
  #
  # source://june-analytics-ruby//lib/june/analytics/utils.rb#41
  def isoify_dates!(hash); end

  # source://june-analytics-ruby//lib/june/analytics/utils.rb#79
  def seconds_to_utc_offset(seconds, colon = T.unsafe(nil)); end

  # public: Return a new hash with keys as strings
  #
  # source://june-analytics-ruby//lib/june/analytics/utils.rb#24
  def stringify_keys(hash); end

  # public: Return a new hash with keys converted from strings to symbols
  #
  # source://june-analytics-ruby//lib/june/analytics/utils.rb#10
  def symbolize_keys(hash); end

  # public: Convert hash keys from strings to symbols in place
  #
  # source://june-analytics-ruby//lib/june/analytics/utils.rb#18
  def symbolize_keys!(hash); end

  # source://june-analytics-ruby//lib/june/analytics/utils.rb#67
  def time_in_iso8601(time); end

  # public: Returns a uid string
  #
  # source://june-analytics-ruby//lib/june/analytics/utils.rb#47
  def uid; end
end

# source://june-analytics-ruby//lib/june/analytics/utils.rb#84
June::Analytics::Utils::UTC_OFFSET_WITHOUT_COLON = T.let(T.unsafe(nil), String)

# source://june-analytics-ruby//lib/june/analytics/utils.rb#83
June::Analytics::Utils::UTC_OFFSET_WITH_COLON = T.let(T.unsafe(nil), String)

# source://june-analytics-ruby//lib/june/analytics/version.rb#3
June::Analytics::VERSION = T.let(T.unsafe(nil), String)

# source://june-analytics-ruby//lib/june/analytics/worker.rb#8
class June::Analytics::Worker
  include ::June::Analytics::Utils
  include ::June::Analytics::Defaults
  include ::June::Analytics::Logging

  # public: Creates a new worker
  #
  # The worker continuously takes messages off the queue
  # and makes requests to the june.so api
  #
  # queue   - Queue synchronized between client and worker
  # write_key  - String of the project's Write key
  # options - Hash of worker options
  #           batch_size - Fixnum of how many items to send in a batch
  #           on_error   - Proc of what to do on an error
  #
  # @return [Worker] a new instance of Worker
  #
  # source://june-analytics-ruby//lib/june/analytics/worker.rb#24
  def initialize(queue, write_key, options = T.unsafe(nil)); end

  # public: Check whether we have outstanding requests.
  #
  # @return [Boolean]
  #
  # source://june-analytics-ruby//lib/june/analytics/worker.rb#56
  def is_requesting?; end

  # public: Continuously runs the loop to check for new events
  #
  # source://june-analytics-ruby//lib/june/analytics/worker.rb#37
  def run; end

  private

  # source://june-analytics-ruby//lib/june/analytics/worker.rb#62
  def consume_message_from_queue!; end

  class << self
    # source://june-analytics-ruby//lib/june/analytics/logging.rb#49
    def logger; end
  end
end
