# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `json_schemer` gem.
# Please instead update this file by running `bin/tapioca gem json_schemer`.


# Based on code from @robacarp found in issue 48:
# https://github.com/davishmcclurg/json_schemer/issues/48
#
# source://json_schemer//lib/json_schemer/version.rb#2
module JSONSchemer
  class << self
    # source://json_schemer//lib/json_schemer.rb#54
    def schema(schema, **options); end

    private

    # source://json_schemer//lib/json_schemer.rb#74
    def draft_class(schema); end
  end
end

# source://json_schemer//lib/json_schemer/cached_resolver.rb#15
class JSONSchemer::CachedRefResolver < ::JSONSchemer::CachedResolver; end

# source://json_schemer//lib/json_schemer/cached_resolver.rb#3
class JSONSchemer::CachedResolver
  # @return [CachedResolver] a new instance of CachedResolver
  #
  # source://json_schemer//lib/json_schemer/cached_resolver.rb#4
  def initialize(&resolver); end

  # source://json_schemer//lib/json_schemer/cached_resolver.rb#9
  def call(*args); end
end

# source://json_schemer//lib/json_schemer.rb#41
JSONSchemer::DEFAULT_META_SCHEMA = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer.rb#34
JSONSchemer::DRAFT_CLASS_BY_META_SCHEMA = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/errors.rb#5
module JSONSchemer::Errors
  class << self
    # source://json_schemer//lib/json_schemer/errors.rb#7
    def pretty(error); end
  end
end

# source://json_schemer//lib/json_schemer.rb#45
JSONSchemer::FILE_URI_REF_RESOLVER = T.let(T.unsafe(nil), Proc)

# source://json_schemer//lib/json_schemer/format.rb#3
module JSONSchemer::Format
  # source://json_schemer//lib/json_schemer/format.rb#102
  def iri_escape(data); end

  # @raise [URI::InvalidURIError]
  #
  # source://json_schemer//lib/json_schemer/format.rb#82
  def parse_uri_scheme(data); end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/format.rb#60
  def valid_date_time?(data); end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/format.rb#67
  def valid_email?(data); end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/format.rb#71
  def valid_hostname?(data); end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/format.rb#75
  def valid_ip?(data, type); end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/format.rb#53
  def valid_json?(data); end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/format.rb#120
  def valid_json_pointer?(data); end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/format.rb#124
  def valid_relative_json_pointer?(data); end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/format.rb#14
  def valid_spec_format?(data, format); end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/format.rb#89
  def valid_uri?(data); end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/format.rb#95
  def valid_uri_reference?(data); end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/format.rb#113
  def valid_uri_template?(data); end
end

# source://json_schemer//lib/json_schemer/format.rb#11
JSONSchemer::Format::DATE_TIME_OFFSET_REGEX = T.let(T.unsafe(nil), Regexp)

# this is no good
#
# source://json_schemer//lib/json_schemer/format.rb#5
JSONSchemer::Format::EMAIL_REGEX = T.let(T.unsafe(nil), Regexp)

# source://json_schemer//lib/json_schemer/format.rb#7
JSONSchemer::Format::HOSTNAME_REGEX = T.let(T.unsafe(nil), Regexp)

# source://json_schemer//lib/json_schemer/format.rb#12
JSONSchemer::Format::INVALID_QUERY_REGEX = T.let(T.unsafe(nil), Regexp)

# source://json_schemer//lib/json_schemer/format.rb#9
JSONSchemer::Format::JSON_POINTER_REGEX = T.let(T.unsafe(nil), Regexp)

# source://json_schemer//lib/json_schemer/format.rb#8
JSONSchemer::Format::JSON_POINTER_REGEX_STRING = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/format.rb#6
JSONSchemer::Format::LABEL_REGEX_STRING = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/format.rb#10
JSONSchemer::Format::RELATIVE_JSON_POINTER_REGEX = T.let(T.unsafe(nil), Regexp)

# source://json_schemer//lib/json_schemer.rb#31
class JSONSchemer::InvalidFileURI < ::StandardError; end

# source://json_schemer//lib/json_schemer.rb#29
class JSONSchemer::InvalidRefResolution < ::StandardError; end

# source://json_schemer//lib/json_schemer.rb#30
class JSONSchemer::InvalidRegexpResolution < ::StandardError; end

# source://json_schemer//lib/json_schemer.rb#32
class JSONSchemer::InvalidSymbolKey < ::StandardError; end

# source://json_schemer//lib/json_schemer/schema/base.rb#3
module JSONSchemer::Schema; end

# source://json_schemer//lib/json_schemer/schema/base.rb#4
class JSONSchemer::Schema::Base
  include ::JSONSchemer::Format

  # @raise [InvalidSymbolKey]
  # @return [Base] a new instance of Base
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#50
  def initialize(schema, format: T.unsafe(nil), insert_property_defaults: T.unsafe(nil), before_property_validation: T.unsafe(nil), after_property_validation: T.unsafe(nil), formats: T.unsafe(nil), keywords: T.unsafe(nil), ref_resolver: T.unsafe(nil), regexp_resolver: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#80
  def valid?(data); end

  # source://json_schemer//lib/json_schemer/schema/base.rb#84
  def validate(data); end

  protected

  # source://json_schemer//lib/json_schemer/schema/base.rb#221
  def ids; end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#90
  def valid_instance?(instance); end

  # @yield [error(instance, 'enum')]
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#94
  def validate_instance(instance, &block); end

  private

  # source://json_schemer//lib/json_schemer/schema/base.rb#245
  def child(schema); end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#237
  def custom_format?(format); end

  # source://json_schemer//lib/json_schemer/schema/base.rb#256
  def error(instance, type, details = T.unsafe(nil)); end

  # source://json_schemer//lib/json_schemer/schema/base.rb#624
  def escape_json_pointer_token(token); end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#233
  def format?; end

  # Returns the value of attribute formats.
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#227
  def formats; end

  # source://json_schemer//lib/json_schemer/schema/base.rb#229
  def id_keyword; end

  # source://json_schemer//lib/json_schemer/schema/base.rb#628
  def join_uri(a, b); end

  # Returns the value of attribute keywords.
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#227
  def keywords; end

  # source://json_schemer//lib/json_schemer/schema/base.rb#641
  def pointer_uri(schema, pointer); end

  # Returns the value of attribute ref_resolver.
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#227
  def ref_resolver; end

  # Returns the value of attribute regexp_resolver.
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#227
  def regexp_resolver; end

  # source://json_schemer//lib/json_schemer/schema/base.rb#654
  def resolve_ids(schema, ids = T.unsafe(nil), parent_uri = T.unsafe(nil), pointer = T.unsafe(nil)); end

  # source://json_schemer//lib/json_schemer/schema/base.rb#672
  def resolve_ref(uri); end

  # source://json_schemer//lib/json_schemer/schema/base.rb#676
  def resolve_regexp(pattern); end

  # Returns the value of attribute root.
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#227
  def root; end

  # source://json_schemer//lib/json_schemer/schema/base.rb#617
  def safe_strict_decode64(data); end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#241
  def spec_format?(format); end

  # @yield [error(instance, 'maxItems')]
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#449
  def validate_array(instance, &block); end

  # source://json_schemer//lib/json_schemer/schema/base.rb#269
  def validate_class(instance, &block); end

  # @yield [error(instance, 'format')]
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#350
  def validate_custom_format(instance, custom_format); end

  # @yield [error(instance, 'exclusiveMaximum')]
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#354
  def validate_exclusive_maximum(instance, exclusive_maximum, maximum); end

  # @yield [error(instance, 'exclusiveMinimum')]
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#358
  def validate_exclusive_minimum(instance, exclusive_minimum, minimum); end

  # source://json_schemer//lib/json_schemer/schema/base.rb#392
  def validate_integer(instance, &block); end

  # source://json_schemer//lib/json_schemer/schema/base.rb#383
  def validate_number(instance, &block); end

  # @yield [error(instance, 'maximum')]
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#362
  def validate_numeric(instance, &block); end

  # @yield [error(instance, 'maxProperties')]
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#506
  def validate_object(instance, &block); end

  # source://json_schemer//lib/json_schemer/schema/base.rb#303
  def validate_ref(instance, ref, &block); end

  # @yield [error(instance, 'maxLength')]
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#403
  def validate_string(instance, &block); end

  # source://json_schemer//lib/json_schemer/schema/base.rb#284
  def validate_type(instance, type, &block); end
end

# source://json_schemer//lib/json_schemer/schema/base.rb#24
JSONSchemer::Schema::Base::BOOLEANS = T.let(T.unsafe(nil), Set)

# source://json_schemer//lib/json_schemer/schema/base.rb#22
JSONSchemer::Schema::Base::DEFAULT_REF_RESOLVER = T.let(T.unsafe(nil), Proc)

# source://json_schemer//lib/json_schemer/schema/base.rb#33
JSONSchemer::Schema::Base::ECMA_262_REGEXP_RESOLVER = T.let(T.unsafe(nil), Proc)

# source://json_schemer//lib/json_schemer/schema/base.rb#21
JSONSchemer::Schema::Base::ID_KEYWORD = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/schema/base.rb#41
JSONSchemer::Schema::Base::INSERT_DEFAULT_PROPERTY = T.let(T.unsafe(nil), Proc)

# source://json_schemer//lib/json_schemer/schema/base.rb#7
class JSONSchemer::Schema::Base::Instance < ::Struct
  # Returns the value of attribute after_property_validation
  #
  # @return [Object] the current value of after_property_validation
  def after_property_validation; end

  # Sets the attribute after_property_validation
  #
  # @param value [Object] the value to set the attribute after_property_validation to.
  # @return [Object] the newly set value
  def after_property_validation=(_); end

  # Returns the value of attribute before_property_validation
  #
  # @return [Object] the current value of before_property_validation
  def before_property_validation; end

  # Sets the attribute before_property_validation
  #
  # @param value [Object] the value to set the attribute before_property_validation to.
  # @return [Object] the newly set value
  def before_property_validation=(_); end

  # Returns the value of attribute data
  #
  # @return [Object] the current value of data
  def data; end

  # Sets the attribute data
  #
  # @param value [Object] the value to set the attribute data to.
  # @return [Object] the newly set value
  def data=(_); end

  # Returns the value of attribute data_pointer
  #
  # @return [Object] the current value of data_pointer
  def data_pointer; end

  # Sets the attribute data_pointer
  #
  # @param value [Object] the value to set the attribute data_pointer to.
  # @return [Object] the newly set value
  def data_pointer=(_); end

  # source://json_schemer//lib/json_schemer/schema/base.rb#8
  def merge(data: T.unsafe(nil), data_pointer: T.unsafe(nil), schema: T.unsafe(nil), schema_pointer: T.unsafe(nil), parent_uri: T.unsafe(nil), before_property_validation: T.unsafe(nil), after_property_validation: T.unsafe(nil)); end

  # Returns the value of attribute parent_uri
  #
  # @return [Object] the current value of parent_uri
  def parent_uri; end

  # Sets the attribute parent_uri
  #
  # @param value [Object] the value to set the attribute parent_uri to.
  # @return [Object] the newly set value
  def parent_uri=(_); end

  # Returns the value of attribute schema
  #
  # @return [Object] the current value of schema
  def schema; end

  # Sets the attribute schema
  #
  # @param value [Object] the value to set the attribute schema to.
  # @return [Object] the newly set value
  def schema=(_); end

  # Returns the value of attribute schema_pointer
  #
  # @return [Object] the current value of schema_pointer
  def schema_pointer; end

  # Sets the attribute schema_pointer
  #
  # @param value [Object] the value to set the attribute schema_pointer to.
  # @return [Object] the newly set value
  def schema_pointer=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://json_schemer//lib/json_schemer/schema/base.rb#47
JSONSchemer::Schema::Base::JSON_POINTER_TOKEN_ESCAPE_CHARS = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/schema/base.rb#48
JSONSchemer::Schema::Base::JSON_POINTER_TOKEN_ESCAPE_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://json_schemer//lib/json_schemer/schema/base.rb#23
JSONSchemer::Schema::Base::NET_HTTP_REF_RESOLVER = T.let(T.unsafe(nil), Proc)

# source://json_schemer//lib/json_schemer/schema/base.rb#26
JSONSchemer::Schema::Base::RUBY_REGEX_ANCHORS_TO_ECMA_262 = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/schema/draft4.rb#4
class JSONSchemer::Schema::Draft4 < ::JSONSchemer::Schema::Base
  private

  # source://json_schemer//lib/json_schemer/schema/draft4.rb#18
  def id_keyword; end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/schema/draft4.rb#22
  def supported_format?(format); end

  # @yield [error(instance, 'exclusiveMaximum')]
  #
  # source://json_schemer//lib/json_schemer/schema/draft4.rb#26
  def validate_exclusive_maximum(instance, exclusive_maximum, maximum); end

  # @yield [error(instance, 'exclusiveMinimum')]
  #
  # source://json_schemer//lib/json_schemer/schema/draft4.rb#30
  def validate_exclusive_minimum(instance, exclusive_minimum, minimum); end

  # source://json_schemer//lib/json_schemer/schema/draft4.rb#34
  def validate_integer(instance, &block); end
end

# source://json_schemer//lib/json_schemer/schema/draft4.rb#5
JSONSchemer::Schema::Draft4::ID_KEYWORD = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/schema/draft4.rb#6
JSONSchemer::Schema::Draft4::SUPPORTED_FORMATS = T.let(T.unsafe(nil), Set)

# source://json_schemer//lib/json_schemer/schema/draft6.rb#4
class JSONSchemer::Schema::Draft6 < ::JSONSchemer::Schema::Base
  private

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/schema/draft6.rb#20
  def supported_format?(format); end
end

# source://json_schemer//lib/json_schemer/schema/draft6.rb#5
JSONSchemer::Schema::Draft6::SUPPORTED_FORMATS = T.let(T.unsafe(nil), Set)

# source://json_schemer//lib/json_schemer/schema/draft7.rb#4
class JSONSchemer::Schema::Draft7 < ::JSONSchemer::Schema::Base
  private

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/schema/draft7.rb#27
  def supported_format?(format); end
end

# source://json_schemer//lib/json_schemer/schema/draft7.rb#5
JSONSchemer::Schema::Draft7::SUPPORTED_FORMATS = T.let(T.unsafe(nil), Set)

# source://json_schemer//lib/json_schemer.rb#28
class JSONSchemer::UnknownRef < ::StandardError; end

# source://json_schemer//lib/json_schemer.rb#27
class JSONSchemer::UnsupportedMetaSchema < ::StandardError; end

# source://json_schemer//lib/json_schemer/version.rb#3
JSONSchemer::VERSION = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer.rb#43
JSONSchemer::WINDOWS_URI_PATH_REGEX = T.let(T.unsafe(nil), Regexp)
